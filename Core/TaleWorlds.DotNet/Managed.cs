using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using TaleWorlds.Library;

namespace TaleWorlds.DotNet
{
	public static class Managed
	{
		internal static bool Closing { get; private set; } = false;

		internal static Dictionary<string, Type> ModuleTypes
		{
			get
			{
				return Managed._moduleTypes;
			}
		}

		internal static NativeTelemetryManager NativeTelemetryManager { get; private set; } = new NativeTelemetryManager();

		static Managed()
		{
			Debug.TelemetryManager = Managed.NativeTelemetryManager;
		}

		public static string ManagedCallbacksDll
		{
			get
			{
				return ManagedDllFolder.Name + "TaleWorlds.DotNet.AutoGenerated.dll";
			}
		}

		[LibraryCallback]
		internal static void SetLogsFolder(string logFolder)
		{
		}

		[LibraryCallback]
		public static string GetStackTraceStr(int skipCount = 0)
		{
			string text = new StackTrace(skipCount, true).ToString();
			text = text.Replace("\r", "");
			text = text.Replace("   ", "");
			if (text.Length >= 16)
			{
				return text;
			}
			return "";
		}

		[LibraryCallback]
		public static string GetStackTraceRaw(int skipCount = 0)
		{
			return Managed.GetStackTraceRaw(new StackTrace(0, false), skipCount);
		}

		public static string GetStackTraceRaw(StackTrace stack, int skipCount = 0)
		{
			MBStringBuilder mbstringBuilder = default(MBStringBuilder);
			mbstringBuilder.Initialize(16, "GetStackTraceRaw");
			for (int i = 0; i < stack.FrameCount; i++)
			{
				if (i >= skipCount)
				{
					string text = "unknown_module.dll";
					try
					{
						StackFrame frame = stack.GetFrame(i);
						MethodBase method = frame.GetMethod();
						text = method.Module.Assembly.Location;
						int iloffset = frame.GetILOffset();
						int metadataToken = method.MetadataToken;
						mbstringBuilder.AppendLine<string>(string.Concat(new object[] { text, "@", metadataToken, "@", iloffset }));
					}
					catch
					{
						mbstringBuilder.AppendLine<string>(text + "@-1@-1");
					}
				}
			}
			return mbstringBuilder.ToStringAndRelease();
		}

		[LibraryCallback]
		public static string GetModuleList()
		{
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			string text = "";
			foreach (Assembly assembly in assemblies)
			{
				try
				{
					text += assembly.Location;
					text += "\n";
				}
				catch
				{
				}
			}
			return text;
		}

		[LibraryCallback]
		public static void GetVersionInts(ref int major, ref int minor, ref int revision)
		{
			ApplicationVersion applicationVersion = ApplicationVersion.FromParametersFile(null);
			major = applicationVersion.Major;
			minor = applicationVersion.Minor;
			revision = applicationVersion.Revision;
		}

		[LibraryCallback]
		internal static DotNetObject CreateCustomParameterStringArray(int length)
		{
			return new CustomParameter<string[]>(new string[length]);
		}

		internal static DotNetObject AddCustomParameter<T>(T parameterData) where T : class
		{
			return new CustomParameter<T>(parameterData);
		}

		[LibraryCallback]
		internal static void GarbageCollect(bool forceTimer)
		{
			Common.MemoryCleanupGC(forceTimer);
		}

		[LibraryCallback]
		internal static void SetStringArrayValueAtIndex(string[] array, int index, string value)
		{
			array[index] = value;
		}

		[LibraryCallback]
		internal static string GetStringArrayValueAtIndex(string[] array, int index)
		{
			return array[index];
		}

		internal static void PassInitializationMethodPointersForMono(IntPtr a, IntPtr b)
		{
			Managed.PassManagedInitializeMethodPointerMono = (Managed.PassManagedInitializeMethodPointerDelegate)Marshal.GetDelegateForFunctionPointer(a, typeof(Managed.PassManagedInitializeMethodPointerDelegate));
			Managed.PassManagedEngineCallbackMethodPointersMono = (Managed.PassManagedCallbackMethodPointersDelegate)Marshal.GetDelegateForFunctionPointer(b, typeof(Managed.PassManagedCallbackMethodPointersDelegate));
		}

		public static void PassInitializationMethodPointersForDotNet(Delegate a, Delegate b)
		{
			Managed.PassManagedInitializeMethodPointerMono = a;
			Managed.PassManagedEngineCallbackMethodPointersMono = b;
		}

		public static void Start(IEnumerable<IManagedComponent> components)
		{
			Managed._components.AddRange(components);
			Common.SetInvariantCulture();
			AppDomain.CurrentDomain.AppendPrivatePath(ManagedDllFolder.Name);
			AssemblyLoader.Initialize();
			Managed._initializer = new ManagedInitializeMethod(Managed.Initialize);
			Managed.PassManagedInitializeMethodPointer(Managed._initializer);
			for (int i = 0; i < Managed._components.Count; i++)
			{
				Managed._components[i].OnStart();
			}
		}

		[MonoPInvokeCallback(typeof(ManagedInitializeMethod))]
		private static void Initialize()
		{
			Common.SetInvariantCulture();
			List<Type> typesSafe = AssemblyLoader.LoadFrom(Managed.ManagedCallbacksDll, true).GetTypesSafe(null);
			Type type = null;
			foreach (Type type2 in typesSafe)
			{
				if (type2.GetInterfaces().Contains(typeof(ICallbackManager)))
				{
					type = type2;
					break;
				}
			}
			Managed._callbackManager = type.GetConstructor(new Type[0]).Invoke(new object[0]) as ICallbackManager;
			Managed._callbackManager.Initialize();
			Delegate[] delegates = Managed._callbackManager.GetDelegates();
			for (int i = 0; i < delegates.Length; i++)
			{
				try
				{
					Managed.PassManagedEngineCallbackMethodPointers(delegates[i]);
				}
				catch (Exception ex)
				{
					Managed.PassManagedEngineCallbackMethodPointers(null);
					Console.WriteLine(ex + " " + i);
				}
			}
			LibraryApplicationInterface.SetObjects(Managed._callbackManager.GetScriptingInterfaceObjects());
		}

		[LibraryCallback]
		internal static void CheckSharedStructureSizes()
		{
			Managed._callbackManager.CheckSharedStructureSizes();
		}

		[LibraryCallback]
		internal static void SetClosing()
		{
			Managed.Closing = true;
		}

		[LibraryCallback]
		internal static void PreFinalize()
		{
			Managed.Closing = true;
			Managed._moduleTypes = null;
			ManagedObjectOwner.PreFinalizeManagedObjects();
			Common.MemoryCleanupGC(false);
		}

		[LibraryCallback]
		internal static void OnFinalize()
		{
			ManagedObject.FinalizeManagedObjects();
			Common.MemoryCleanupGC(false);
			ManagedObjectOwner.LogFinalize();
		}

		[LibraryCallback]
		internal static void ApplicationTick(float dt)
		{
			ManagedObject.HandleManagedObjects();
			DotNetObject.HandleDotNetObjects();
			NativeObject.HandleNativeObjects();
			ManagedObjectOwner.GarbageCollect();
			Managed.NativeTelemetryManager.Update();
			for (int i = 0; i < Managed._components.Count; i++)
			{
				Managed._components[i].OnApplicationTick(dt);
			}
		}

		[LibraryCallback]
		internal static void ApplicationTickLight(float dt)
		{
			DotNetObject.HandleDotNetObjects();
			NativeObject.HandleNativeObjects();
			Managed.NativeTelemetryManager.Update();
			for (int i = 0; i < Managed._components.Count; i++)
			{
				Managed._components[i].OnApplicationTick(dt);
			}
		}

		[LibraryCallback]
		internal static bool CheckClassNameIsValid(string className)
		{
			return Managed._moduleTypes.ContainsKey(className);
		}

		[LibraryCallback]
		internal static int GetStringArrayLength(string[] array)
		{
			return array.Length;
		}

		[LibraryCallback]
		internal static string[] GetClassFields(string className, bool recursive, bool includeInternal, bool includeProtected, bool includePrivate)
		{
			List<string> list = new List<string>();
			Type type;
			if (Managed._moduleTypes.TryGetValue(className, out type))
			{
				FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				for (int i = 0; i < fields.Length; i++)
				{
					FieldInfo fieldInfo = fields[i];
					if (false || fieldInfo.IsPublic || (includePrivate && fieldInfo.IsPrivate) || (includeProtected && fieldInfo.IsFamily) || (includeInternal && fieldInfo.IsAssembly))
					{
						list.Add(fields[i].Name);
					}
				}
			}
			return list.ToArray();
		}

		[LibraryCallback]
		internal static ManagedObject CreateObjectClassInstanceWithPointer(string className, IntPtr pointer)
		{
			ConstructorInfo constructor = Managed._moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Type[] { typeof(IntPtr) }, null);
			if (constructor != null)
			{
				object obj = constructor.Invoke(new object[] { pointer });
				if (obj != null)
				{
					return obj as ManagedObject;
				}
			}
			return null;
		}

		internal static string GetClassNamesAux(Type type)
		{
			string text = "";
			Predicate<Type> <>9__0;
			foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
			{
				if (!assembly.GlobalAssemblyCache)
				{
					try
					{
						Type[] types = assembly.GetTypes();
						Predicate<Type> predicate;
						if ((predicate = <>9__0) == null)
						{
							predicate = (<>9__0 = (Type t) => (t.Equals(type) || t.IsSubclassOf(type)) && !t.IsAbstract);
						}
						string[] array = Array.ConvertAll<Type, string>(Array.FindAll<Type>(types, predicate), (Type t) => t.Name);
						if (array.Length != 0)
						{
							if (text != "")
							{
								text += " ";
							}
							text += string.Join(" ", array);
						}
					}
					catch (ReflectionTypeLoadException ex)
					{
						Debug.Print(ex.Message + " " + ex.GetType(), 0, Debug.DebugColor.White, 17592186044416UL);
						foreach (object obj in ex.Data.Values)
						{
							Debug.Print(obj.ToString(), 0, Debug.DebugColor.White, 17592186044416UL);
						}
					}
				}
			}
			return text;
		}

		[LibraryCallback]
		internal static ManagedObject CreateObjectClassInstanceWithInteger(string className, int value)
		{
			ConstructorInfo constructor = Managed._moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Type[] { typeof(int) }, null);
			if (constructor != null)
			{
				object obj = constructor.Invoke(new object[] { value });
				if (obj != null)
				{
					return obj as ManagedObject;
				}
			}
			return null;
		}

		[LibraryCallback]
		internal static void SetCurrentStringReturnValue(IntPtr pointer)
		{
			Managed.ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);
		}

		[LibraryCallback]
		internal static void SetCurrentStringReturnValueAsUnicode(IntPtr pointer)
		{
			Managed.ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);
			byte[] bytes = Encoding.Default.GetBytes(Managed.ReturnValueFromEngine);
			byte[] array = Encoding.Convert(Encoding.UTF8, Encoding.Unicode, bytes);
			Managed.ReturnValueFromEngine = Encoding.Unicode.GetString(array);
		}

		[LibraryCallback]
		internal static string GetObjectClassName(string className)
		{
			Type type;
			if (Managed._moduleTypes.TryGetValue(className, out type))
			{
				return type.Name;
			}
			return "unknown";
		}

		[LibraryCallback]
		internal static void EngineApiMethodInterfaceInitializer(int id, IntPtr pointer)
		{
			Managed._engineApiPointers.Add(id, pointer);
		}

		[LibraryCallback]
		internal static void FillEngineApiPointers()
		{
			foreach (KeyValuePair<int, IntPtr> keyValuePair in Managed._engineApiPointers)
			{
				try
				{
					Managed._callbackManager.SetFunctionPointer(keyValuePair.Key, keyValuePair.Value);
				}
				catch (Exception ex)
				{
					Console.WriteLine(string.Concat(new object[] { "error: ", keyValuePair.Key, " ", ex }));
				}
			}
		}

		[LibraryCallback]
		internal static long GetMemoryUsage()
		{
			return GC.GetTotalMemory(false);
		}

		[LibraryCallback]
		internal static void PassCustomCallbackMethodPointers(string name, IntPtr initalizer)
		{
			Delegate delegateForFunctionPointer = Marshal.GetDelegateForFunctionPointer(initalizer, typeof(Managed.InitializerDelegate));
			for (int i = 0; i < Managed._components.Count; i++)
			{
				Managed._components[i].OnCustomCallbackMethodPassed(name, delegateForFunctionPointer);
			}
		}

		[LibraryCallback]
		internal static string CallCommandlineFunction(string functionName, string arguments)
		{
			bool flag;
			return CommandLineFunctionality.CallFunction(functionName, arguments, out flag);
		}

		public static void InitializeTypes(Dictionary<string, Type> types)
		{
			Managed._moduleTypes = types;
			foreach (KeyValuePair<string, Type> keyValuePair in types)
			{
				Dictionary<string, FieldInfo> dictionary = new Dictionary<string, FieldInfo>();
				Dictionary<string, FieldInfo> dictionary2 = new Dictionary<string, FieldInfo>();
				BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
				foreach (FieldInfo fieldInfo in keyValuePair.Value.GetFields(bindingFlags))
				{
					string name = fieldInfo.Name;
					object[] customAttributes = fieldInfo.GetCustomAttributes(typeof(EditableScriptComponentVariable), true);
					bool flag = false;
					if (customAttributes.Length != 0)
					{
						flag = ((EditableScriptComponentVariable)customAttributes[0]).Visible;
					}
					else if (!fieldInfo.IsPrivate && !fieldInfo.IsFamily)
					{
						flag = true;
					}
					if (flag)
					{
						dictionary2.Add(name, fieldInfo);
					}
					dictionary.Add(name, fieldInfo);
				}
				Managed._fieldsOfScriptsCached.Add(keyValuePair.Key, dictionary);
				Managed._editableFieldsOfScriptsCached.Add(keyValuePair.Key, dictionary2);
				bindingFlags |= BindingFlags.CreateInstance;
				ConstructorInfo constructor = keyValuePair.Value.GetConstructor(bindingFlags, null, new Type[0], null);
				Managed._constructorsOfScriptsCached.Add(keyValuePair.Key, constructor);
			}
		}

		public static void AddTypes(Dictionary<string, Type> types)
		{
			Managed._moduleTypes = Managed._moduleTypes.Union(types).ToDictionary((KeyValuePair<string, Type> k) => k.Key, (KeyValuePair<string, Type> v) => v.Value);
			foreach (KeyValuePair<string, Type> keyValuePair in types)
			{
				Dictionary<string, FieldInfo> dictionary = new Dictionary<string, FieldInfo>();
				Dictionary<string, FieldInfo> dictionary2 = new Dictionary<string, FieldInfo>();
				BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
				foreach (FieldInfo fieldInfo in keyValuePair.Value.GetFields(bindingFlags))
				{
					string name = fieldInfo.Name;
					object[] customAttributes = fieldInfo.GetCustomAttributes(typeof(EditableScriptComponentVariable), true);
					bool flag = false;
					if (customAttributes.Length != 0)
					{
						flag = ((EditableScriptComponentVariable)customAttributes[0]).Visible;
					}
					else if (!fieldInfo.IsPrivate && !fieldInfo.IsFamily)
					{
						flag = true;
					}
					if (flag)
					{
						dictionary2.Add(name, fieldInfo);
					}
					dictionary.Add(name, fieldInfo);
				}
				Managed._fieldsOfScriptsCached.Add(keyValuePair.Key, dictionary);
				Managed._editableFieldsOfScriptsCached.Add(keyValuePair.Key, dictionary2);
				bindingFlags |= BindingFlags.CreateInstance;
				ConstructorInfo constructor = keyValuePair.Value.GetConstructor(bindingFlags, null, new Type[0], null);
				Managed._constructorsOfScriptsCached.Add(keyValuePair.Key, constructor);
			}
		}

		public static void AddConstructorDelegateOfClass<T>()
		{
			Type typeFromHandle = typeof(T);
			string name = typeFromHandle.Name;
			if (!Managed._constructorDelegatesOfScriptsCached.ContainsKey(name))
			{
				Managed._constructorDelegatesOfScriptsCached[name] = Expression.Lambda<Func<T>>(Expression.New(typeFromHandle), Array.Empty<ParameterExpression>()).Compile();
			}
		}

		public static void AddConstructorDelegateOfWeakReferenceClass<T>()
		{
			Type typeFromHandle = typeof(T);
			if (!Managed._constructorDelegatesOfWeakReferencesCached.ContainsKey(typeFromHandle))
			{
				Managed._constructorDelegatesOfWeakReferencesCached[typeFromHandle] = Expression.Lambda<Func<T>>(Expression.New(typeFromHandle), Array.Empty<ParameterExpression>()).Compile();
			}
		}

		private static void PassManagedInitializeMethodPointer(Delegate initializer)
		{
			Delegate passManagedInitializeMethodPointerMono = Managed.PassManagedInitializeMethodPointerMono;
			if (passManagedInitializeMethodPointerMono == null)
			{
				return;
			}
			passManagedInitializeMethodPointerMono.DynamicInvoke(new object[] { initializer });
		}

		private static void PassManagedEngineCallbackMethodPointers(Delegate methodDelegate)
		{
			Delegate passManagedEngineCallbackMethodPointersMono = Managed.PassManagedEngineCallbackMethodPointersMono;
			if (passManagedEngineCallbackMethodPointersMono == null)
			{
				return;
			}
			passManagedEngineCallbackMethodPointersMono.DynamicInvoke(new object[] { methodDelegate });
		}

		[LibraryCallback]
		internal static void LoadManagedComponent(string assemblyName, string managedInterface)
		{
			IManagedComponent managedComponent = (IManagedComponent)Activator.CreateInstance(AssemblyLoader.LoadFrom(ManagedDllFolder.Name + assemblyName + ".dll", true).GetType(managedInterface));
			Managed._components.Add(managedComponent);
			managedComponent.OnStart();
		}

		internal static Dictionary<string, FieldInfo> GetEditableFieldsOfClass(string className)
		{
			Dictionary<string, FieldInfo> dictionary;
			Managed._editableFieldsOfScriptsCached.TryGetValue(className, out dictionary);
			return dictionary;
		}

		internal static FieldInfo GetFieldOfClass(string className, string fieldName)
		{
			Dictionary<string, FieldInfo> dictionary;
			if (Managed._fieldsOfScriptsCached.TryGetValue(className, out dictionary))
			{
				FieldInfo fieldInfo;
				dictionary.TryGetValue(fieldName, out fieldInfo);
				return fieldInfo;
			}
			return null;
		}

		internal static ConstructorInfo GetConstructorOfClass(string className)
		{
			ConstructorInfo constructorInfo;
			Managed._constructorsOfScriptsCached.TryGetValue(className, out constructorInfo);
			return constructorInfo;
		}

		internal static Delegate GetConstructorDelegateOfClass(string className)
		{
			Delegate @delegate;
			Managed._constructorDelegatesOfScriptsCached.TryGetValue(className, out @delegate);
			return @delegate;
		}

		internal static Delegate GetConstructorDelegateOfWeakReferenceClass(Type classType)
		{
			return Managed._constructorDelegatesOfWeakReferencesCached[classType];
		}

		[LibraryCallback]
		internal static bool IsClassFieldExists(string className, string fieldName)
		{
			return Managed.GetFieldOfClass(className, fieldName) != null;
		}

		[LibraryCallback]
		internal static string GetEnumNamesOfField(string className, string fieldName)
		{
			string text = Managed.GetFieldOfClass(className, fieldName).FieldType.FullName;
			string text2 = text.Substring(0, text.IndexOf('.'));
			if (text2 != null && text2 != "" && text2 != Assembly.GetExecutingAssembly().GetName().Name)
			{
				text = text + ", " + text2;
			}
			Type type = Type.GetType(text);
			if (type == null)
			{
				int num = text.IndexOf(',');
				text = text.Remove(num);
				Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
				for (int i = 0; i < assemblies.Length; i++)
				{
					type = assemblies[i].GetType(text);
					if (type != null)
					{
						break;
					}
				}
			}
			type.GetEnumValues();
			string[] enumNames = type.GetEnumNames();
			return string.Join(" ", enumNames);
		}

		[CommandLineFunctionality.CommandLineArgumentFunction("show_version", "dotnet")]
		public static string ShowDotNetVersion(List<string> strings)
		{
			string frameworkDescription = RuntimeInformation.FrameworkDescription;
			Debug.Print("Version:" + frameworkDescription, 0, Debug.DebugColor.White, 17592186044416UL);
			return frameworkDescription;
		}

		private static List<IManagedComponent> _components = new List<IManagedComponent>();

		private static ICallbackManager _callbackManager;

		internal static string ReturnValueFromEngine = "";

		private static ManagedInitializeMethod _initializer;

		private static Dictionary<string, Type> _moduleTypes;

		private static Dictionary<int, IntPtr> _engineApiPointers = new Dictionary<int, IntPtr>();

		private static Dictionary<string, Dictionary<string, FieldInfo>> _fieldsOfScriptsCached = new Dictionary<string, Dictionary<string, FieldInfo>>();

		private static Dictionary<string, Dictionary<string, FieldInfo>> _editableFieldsOfScriptsCached = new Dictionary<string, Dictionary<string, FieldInfo>>();

		private static Dictionary<string, ConstructorInfo> _constructorsOfScriptsCached = new Dictionary<string, ConstructorInfo>();

		private static Dictionary<string, Delegate> _constructorDelegatesOfScriptsCached = new Dictionary<string, Delegate>();

		private static Dictionary<Type, Delegate> _constructorDelegatesOfWeakReferencesCached = new Dictionary<Type, Delegate>();

		private static Delegate PassManagedInitializeMethodPointerMono = null;

		private static Delegate PassManagedEngineCallbackMethodPointersMono = null;

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		[MonoNativeFunctionWrapper]
		public delegate void PassManagedInitializeMethodPointerDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate initalizer);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		[MonoNativeFunctionWrapper]
		public delegate void PassManagedCallbackMethodPointersDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate methodDelegate);

		[MonoNativeFunctionWrapper]
		public delegate void InitializerDelegate(Delegate argument);

		public enum RglScriptFieldType
		{
			RglSftString,
			RglSftDouble,
			RglSftFloat,
			RglSftBool,
			RglSftInt,
			RglSftVec3,
			RglSftEntity,
			RglSftTexture,
			RglSftMesh,
			RglSftEnum,
			RglSftMaterial,
			RglSftButton,
			RglSftColor,
			RglSftMatrixFrame
		}
	}
}
