using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.DotNet;
using TaleWorlds.Engine;
using TaleWorlds.Library;

namespace TaleWorlds.MountAndBlade
{
	public class StrategicArea : MissionObject, IDetachment
	{
		public bool IsLoose
		{
			get
			{
				return true;
			}
		}

		public MBReadOnlyList<Formation> UserFormations
		{
			get
			{
				return this._userFormations;
			}
		}

		public float DistanceToCheck
		{
			get
			{
				return this._distanceToCheck;
			}
		}

		public bool IgnoreHeight
		{
			get
			{
				return this._ignoreHeight;
			}
		}

		public bool IsActive
		{
			get
			{
				return this._isActive;
			}
			set
			{
				if (value != this._isActive)
				{
					List<Team> list = Mission.Current.Teams.Where((Team t) => this.IsUsableBy(t.Side)).ToList<Team>();
					this._isActive = value;
					foreach (Team team in list)
					{
						if (team.TeamAI != null)
						{
							if (this._isActive)
							{
								team.TeamAI.AddStrategicArea(this);
							}
							else
							{
								team.TeamAI.RemoveStrategicArea(this);
							}
						}
					}
				}
			}
		}

		protected internal override void OnInit()
		{
			base.OnInit();
			this._agents = new List<Agent>();
			this._userFormations = new MBList<Formation>();
			MatrixFrame globalFrame = base.GameEntity.GetGlobalFrame();
			this._frame = new WorldFrame(globalFrame.rotation, new WorldPosition(base.Scene, UIntPtr.Zero, globalFrame.origin, false));
			this._frame.Rotation.Orthonormalize();
			this._unitSpacing = ArrangementOrder.GetUnitSpacingOf(ArrangementOrder.ArrangementOrderEnum.Line);
			this._capacity = this.CalculateCapacity();
			this._simulationFormations = new Dictionary<Formation, Formation>();
			this._isActive = true;
			for (int i = 0; i < 5; i++)
			{
				this._strategicAreaSidesScoreTally[i] = new StrategicArea.StrategicAreaMutableTuple(0, 0);
			}
		}

		private int CalculateCapacity()
		{
			return MathF.Max(1, MathF.Ceiling(MathF.Max(1f, this._width) * MathF.Max(1f, this._depth)));
		}

		public Vec3 GetGroundPosition()
		{
			return this._frame.Origin.GetGroundVec3();
		}

		public void DetermineAssociatedDestructibleComponents(IEnumerable<DestructableComponent> destructibleComponents)
		{
			this._nearbyDestructibleObjects = new List<DestructableComponent>();
			foreach (DestructableComponent destructableComponent in destructibleComponents)
			{
				destructableComponent.GameEntity.GetGlobalFrame();
				Vec3 vec;
				Vec3 vec2;
				destructableComponent.GameEntity.GetPhysicsMinMax(true, out vec, out vec2, false);
				if (((vec2 + vec) * 0.5f).DistanceSquared(base.GameEntity.GlobalPosition) <= 9f)
				{
					this._nearbyDestructibleObjects.Add(destructableComponent);
				}
			}
			foreach (DestructableComponent destructableComponent2 in this._nearbyDestructibleObjects)
			{
				destructableComponent2.OnDestroyed += new DestructableComponent.OnHitTakenAndDestroyedDelegate(this.OnCoveringDestructibleObjectDestroyed);
			}
		}

		public void OnParentGameEntityVisibilityChanged(bool isVisible)
		{
			this.IsActive = isVisible;
		}

		private void OnCoveringDestructibleObjectDestroyed(DestructableComponent destroyedComponent, Agent destroyerAgent, in MissionWeapon weapon, ScriptComponentBehavior attackerScriptComponentBehavior, int inflictedDamage)
		{
			this.IsActive = false;
		}

		protected override void OnRemoved(int removeReason)
		{
			base.OnRemoved(removeReason);
			foreach (DestructableComponent destructableComponent in this._nearbyDestructibleObjects)
			{
				destructableComponent.OnDestroyed -= new DestructableComponent.OnHitTakenAndDestroyedDelegate(this.OnCoveringDestructibleObjectDestroyed);
			}
		}

		public void InitializeAutogenerated(float width, int capacity, BattleSideEnum side)
		{
			this._width = width;
			this._capacity = capacity;
			this._side = side;
		}

		public void AddAgent(Agent agent, int slotIndex)
		{
			this._agents.Add(agent);
			if (this._capacity == 1 && this._centerPosition == null)
			{
				this._centerPosition = new WorldPosition?(this._frame.Origin);
				Mat3 identity = Mat3.Identity;
				identity.f = base.GameEntity.GetGlobalFrame().rotation.f;
				identity.OrthonormalizeAccordingToForwardAndKeepUpAsZAxis();
				this._cachedWorldFrame = new WorldFrame(identity, this._centerPosition.Value);
			}
		}

		public void AddAgentAtSlotIndex(Agent agent, int slotIndex)
		{
			this.AddAgent(agent, slotIndex);
			Formation formation = agent.Formation;
			if (formation != null)
			{
				formation.DetachUnit(agent, true);
			}
			agent.Detachment = this;
			agent.DetachmentWeight = 1f;
		}

		void IDetachment.FormationStartUsing(Formation formation)
		{
			this._userFormations.Add(formation);
		}

		void IDetachment.FormationStopUsing(Formation formation)
		{
			this._userFormations.Remove(formation);
		}

		public bool IsUsedByFormation(Formation formation)
		{
			return this._userFormations.Contains(formation);
		}

		Agent IDetachment.GetMovingAgentAtSlotIndex(int slotIndex)
		{
			return null;
		}

		void IDetachment.GetSlotIndexWeightTuples(List<ValueTuple<int, float>> slotIndexWeightTuples)
		{
			for (int i = this._agents.Count; i < this._capacity; i++)
			{
				slotIndexWeightTuples.Add(new ValueTuple<int, float>(i, StrategicArea.CalculateWeight(this._capacity, i)));
			}
		}

		bool IDetachment.IsSlotAtIndexAvailableForAgent(int slotIndex, Agent agent)
		{
			return agent.CanBeAssignedForScriptedMovement() && slotIndex < this._capacity && slotIndex >= this._agents.Count && this.IsAgentEligible(agent) && !this.IsAgentOnInconvenientNavmesh(agent);
		}

		private bool IsAgentOnInconvenientNavmesh(Agent agent)
		{
			if (Mission.Current.MissionTeamAIType != Mission.MissionTeamAITypeEnum.Siege)
			{
				return false;
			}
			int currentNavigationFaceId = agent.GetCurrentNavigationFaceId();
			TeamAISiegeComponent teamAISiegeComponent;
			if ((teamAISiegeComponent = agent.Team.TeamAI as TeamAISiegeComponent) != null)
			{
				if (teamAISiegeComponent is TeamAISiegeAttacker && currentNavigationFaceId % 10 == 1)
				{
					return true;
				}
				if (teamAISiegeComponent is TeamAISiegeDefender && currentNavigationFaceId % 10 != 1)
				{
					return true;
				}
				foreach (int num in teamAISiegeComponent.DifficultNavmeshIDs)
				{
					if (currentNavigationFaceId == num)
					{
						return true;
					}
				}
				return false;
			}
			return false;
		}

		public bool IsAgentEligible(Agent agent)
		{
			return agent.IsRangedCached;
		}

		void IDetachment.UnmarkDetachment()
		{
		}

		bool IDetachment.IsDetachmentRecentlyEvaluated()
		{
			return false;
		}

		void IDetachment.MarkSlotAtIndex(int slotIndex)
		{
			Debug.FailedAssert("This should never have been called because this detachment does not seek to replace moving agents.", "C:\\Develop\\MB3\\Source\\Bannerlord\\TaleWorlds.MountAndBlade\\AI\\StrategicArea.cs", "MarkSlotAtIndex", 322);
		}

		bool IDetachment.IsAgentUsingOrInterested(Agent agent)
		{
			return this._agents.Contains(agent);
		}

		void IDetachment.OnFormationLeave(Formation formation)
		{
			for (int i = this._agents.Count - 1; i >= 0; i--)
			{
				Agent agent = this._agents[i];
				if (agent.Formation == formation && !agent.IsPlayerControlled)
				{
					((IDetachment)this).RemoveAgent(agent);
					formation.AttachUnit(agent);
				}
			}
		}

		public bool IsStandingPointAvailableForAgent(Agent agent)
		{
			return this._agents.Count < this._capacity;
		}

		public List<float> GetTemplateCostsOfAgent(Agent candidate, List<float> oldValue)
		{
			WorldPosition worldPosition = candidate.GetWorldPosition();
			float num = (candidate.Mission.Scene.DoesPathExistBetweenPositions(worldPosition, this._frame.Origin) ? worldPosition.GetNavMeshVec3().DistanceSquared(this._frame.Origin.GetNavMeshVec3()) : float.MaxValue);
			num *= MissionGameModels.Current.AgentStatCalculateModel.GetDetachmentCostMultiplierOfAgent(candidate, this);
			List<float> list = oldValue ?? new List<float>(this._capacity);
			list.Clear();
			for (int i = 0; i < this._capacity; i++)
			{
				list.Add(num);
			}
			return list;
		}

		float IDetachment.GetExactCostOfAgentAtSlot(Agent candidate, int slotIndex)
		{
			Debug.FailedAssert("This should never have been called because this detachment does not seek to replace moving agents.", "C:\\Develop\\MB3\\Source\\Bannerlord\\TaleWorlds.MountAndBlade\\AI\\StrategicArea.cs", "GetExactCostOfAgentAtSlot", 372);
			return 0f;
		}

		public float GetTemplateWeightOfAgent(Agent candidate)
		{
			WorldPosition worldPosition = candidate.GetWorldPosition();
			WorldPosition origin = this._frame.Origin;
			if (!candidate.Mission.Scene.DoesPathExistBetweenPositions(worldPosition, origin))
			{
				return float.MaxValue;
			}
			return worldPosition.GetNavMeshVec3().DistanceSquared(origin.GetNavMeshVec3());
		}

		public float? GetWeightOfAgentAtNextSlot(List<Agent> newAgents, out Agent match)
		{
			float? weightOfNextSlot = this.GetWeightOfNextSlot(newAgents[0].Team.Side);
			if (this._agents.Count < this._capacity)
			{
				Vec3 position = base.GameEntity.GlobalPosition;
				match = newAgents.MinBy((Agent a) => a.Position.DistanceSquared(position));
				return weightOfNextSlot;
			}
			match = null;
			return null;
		}

		public float? GetWeightOfAgentAtNextSlot(List<ValueTuple<Agent, float>> agentTemplateScores, out Agent match)
		{
			float? weight = this.GetWeightOfNextSlot(agentTemplateScores[0].Item1.Team.Side);
			if (this._agents.Count < this._capacity)
			{
				IEnumerable<ValueTuple<Agent, float>> enumerable = agentTemplateScores.Where(delegate(ValueTuple<Agent, float> a)
				{
					Agent item = a.Item1;
					if (item.IsDetachedFromFormation)
					{
						float detachmentWeight = item.DetachmentWeight;
						float? num = weight * 0.4f;
						return (detachmentWeight < num.GetValueOrDefault()) & (num != null);
					}
					return true;
				});
				if (enumerable.Any<ValueTuple<Agent, float>>())
				{
					match = enumerable.MinBy((ValueTuple<Agent, float> a) => a.Item2).Item1;
					return weight;
				}
			}
			match = null;
			return null;
		}

		public float? GetWeightOfAgentAtOccupiedSlot(Agent detachedAgent, List<Agent> newAgents, out Agent match)
		{
			float weightOfOccupiedSlot = this.GetWeightOfOccupiedSlot(detachedAgent);
			Vec3 position = base.GameEntity.GlobalPosition;
			match = newAgents.MinBy((Agent a) => a.Position.DistanceSquared(position));
			return new float?(weightOfOccupiedSlot * 0.5f);
		}

		public void RemoveAgent(Agent agent)
		{
			this._agents.Remove(agent);
		}

		private Formation GetSimulationFormation(Formation formation)
		{
			if (!this._simulationFormations.ContainsKey(formation))
			{
				this._simulationFormations[formation] = new Formation(null, -1);
			}
			return this._simulationFormations[formation];
		}

		protected internal override bool OnCheckForProblems()
		{
			bool flag = base.OnCheckForProblems();
			if (base.GameEntity.IsVisibleIncludeParents() && this.CalculateCapacity() == 1)
			{
				MatrixFrame globalFrame = base.GameEntity.GetGlobalFrame();
				WorldFrame worldFrame = new WorldFrame(globalFrame.rotation, new WorldPosition(base.Scene, globalFrame.origin));
				if (worldFrame.Origin.GetNavMesh() == UIntPtr.Zero)
				{
					uint upgradeLevelMaskCumulative = (uint)base.GameEntity.GetUpgradeLevelMaskCumulative();
					int upgradeLevelCount = base.Scene.GetUpgradeLevelCount();
					string text = "";
					for (int i = 0; i < upgradeLevelCount; i++)
					{
						if (((ulong)upgradeLevelMaskCumulative & (ulong)(1L << (i & 31))) != 0UL)
						{
							text = text + base.Scene.GetUpgradeLevelNameOfIndex(i) + ",";
						}
					}
					MBEditor.AddEntityWarning(base.GameEntity, string.Concat(new object[]
					{
						"Strategic archer position at position at X=",
						globalFrame.origin.X,
						" Y=",
						globalFrame.origin.Y,
						" Z=",
						globalFrame.origin.Z,
						"doesn't yield a viable frame. It may be in the air, underground or off the navmesh, please check. Scene: ",
						base.Scene.GetName(),
						"Upgrade Mask: ",
						upgradeLevelMaskCumulative,
						", Upgrade Level Names: ",
						text
					}));
					flag = true;
				}
			}
			return flag;
		}

		public WorldFrame? GetAgentFrame(Agent agent)
		{
			if (this._capacity > 1)
			{
				int num = this._agents.IndexOf(agent);
				Formation formation = agent.Formation;
				Formation simulationFormation = this.GetSimulationFormation(formation);
				Formation formation2 = formation;
				Formation formation3 = simulationFormation;
				int num2 = num;
				Vec2 vec = this._frame.Rotation.f.AsVec2;
				vec = vec.Normalized();
				WorldPosition? worldPosition;
				Vec2? vec2;
				formation2.GetUnitPositionWithIndexAccordingToNewOrder(formation3, num2, this._frame.Origin, vec, this._width, this._unitSpacing, this._agents.Count, out worldPosition, out vec2);
				if (worldPosition != null)
				{
					return new WorldFrame?(new WorldFrame(this._frame.Rotation, worldPosition.Value));
				}
				if (this._centerPosition == null)
				{
					MBDebug.ShowWarning(string.Concat(new object[]
					{
						"Strategic archer position at position at X=",
						this._frame.Origin.GetGroundVec3().x,
						" Y=",
						this._frame.Origin.GetGroundVec3().y,
						" Z=",
						this._frame.Origin.GetGroundVec3().z,
						"doesn't yield a viable frame. It may be in the air, underground or off the navmesh, please check. Scene: ",
						base.Scene.GetName()
					}));
				}
				return new WorldFrame?(agent.GetWorldFrame());
			}
			else
			{
				float totalMissionTime = MBCommon.GetTotalMissionTime();
				StrategicArea.ShimmyDirection shimmyDirection = this._shimmyDirection;
				int num3 = 0;
				StrategicArea.StrategicAreaMutableTuple[] strategicAreaSidesScoreTally = this._strategicAreaSidesScoreTally;
				for (int i = 0; i < strategicAreaSidesScoreTally.Length; i++)
				{
					if (strategicAreaSidesScoreTally[i] != null)
					{
						num3++;
					}
				}
				bool flag = num3 > 1;
				if (flag && this._lastShootTime < agent.LastRangedAttackTime)
				{
					this._lastShootTime = agent.LastRangedAttackTime;
					StrategicArea.StrategicAreaMutableTuple strategicAreaMutableTuple = this._strategicAreaSidesScoreTally[(int)this._shimmyDirection];
					if (strategicAreaMutableTuple != null)
					{
						strategicAreaMutableTuple.RangedHitScoredCount++;
					}
					else
					{
						this._strategicAreaSidesScoreTally[(int)this._shimmyDirection] = new StrategicArea.StrategicAreaMutableTuple(0, 1);
					}
				}
				bool flag2 = false;
				if (flag && this._lastShimmyTime < agent.LastRangedHitTime)
				{
					StrategicArea.StrategicAreaMutableTuple strategicAreaMutableTuple2 = this._strategicAreaSidesScoreTally[(int)this._shimmyDirection];
					if (strategicAreaMutableTuple2 != null)
					{
						strategicAreaMutableTuple2.RangedHitReceivedCount++;
					}
					else
					{
						this._strategicAreaSidesScoreTally[(int)this._shimmyDirection] = new StrategicArea.StrategicAreaMutableTuple(1, 0);
					}
					flag2 = true;
				}
				bool flag3 = false;
				if (flag && !flag2 && totalMissionTime - MathF.Max(agent.LastRangedAttackTime, this._lastShimmyTime) > 8f)
				{
					StrategicArea.StrategicAreaMutableTuple strategicAreaMutableTuple3 = this._strategicAreaSidesScoreTally[(int)this._shimmyDirection];
					if (strategicAreaMutableTuple3 != null)
					{
						strategicAreaMutableTuple3.RangedHitScoredCount--;
					}
					else
					{
						this._strategicAreaSidesScoreTally[(int)this._shimmyDirection] = new StrategicArea.StrategicAreaMutableTuple(0, -1);
					}
					flag3 = true;
				}
				if (flag2 || flag3)
				{
					int num4 = int.MinValue;
					int num5 = 0;
					for (int j = 0; j < 5; j++)
					{
						if (j != (int)this._shimmyDirection && this._strategicAreaSidesScoreTally[j] != null)
						{
							int num6 = this._strategicAreaSidesScoreTally[j].RangedHitScoredCount - this._strategicAreaSidesScoreTally[j].RangedHitReceivedCount;
							if (num6 > num4)
							{
								num4 = num6;
								num5 = 1;
							}
							else if (num6 == num4)
							{
								num5++;
							}
						}
					}
					int num7 = MBRandom.RandomInt(num5 - 1);
					for (int k = 0; k < 5; k++)
					{
						if (k != (int)this._shimmyDirection && this._strategicAreaSidesScoreTally[k] != null && this._strategicAreaSidesScoreTally[k].RangedHitScoredCount - this._strategicAreaSidesScoreTally[k].RangedHitReceivedCount == num4 && --num7 < 0)
						{
							shimmyDirection = (StrategicArea.ShimmyDirection)k;
						}
					}
					this._doesFrameNeedUpdate = true;
				}
				if (!this._doesFrameNeedUpdate)
				{
					return new WorldFrame?(this._cachedWorldFrame);
				}
				if (this._centerPosition != null)
				{
					WorldPosition value = this._centerPosition.Value;
					Vec2 vec = this._frame.Rotation.f.AsVec2;
					Vec2 vec3 = vec.Normalized();
					Vec2 vec4;
					switch (shimmyDirection)
					{
					case StrategicArea.ShimmyDirection.Center:
						vec4 = Vec2.Zero;
						break;
					case StrategicArea.ShimmyDirection.Left:
						vec4 = vec3.RightVec();
						break;
					case StrategicArea.ShimmyDirection.Forward:
						vec4 = vec3;
						break;
					case StrategicArea.ShimmyDirection.Right:
						vec4 = vec3.LeftVec();
						break;
					case StrategicArea.ShimmyDirection.Back:
						vec4 = -vec3;
						break;
					default:
						vec4 = Vec2.Zero;
						break;
					}
					WorldPosition worldPosition2 = value;
					int num8 = 8;
					bool flag4 = false;
					while (num8-- > 0)
					{
						value.SetVec2(worldPosition2.AsVec2 + (0.6f + 0.05f * (float)num8) * vec4);
						if (value.GetNavMesh() != UIntPtr.Zero)
						{
							flag4 = true;
							break;
						}
					}
					this._doesFrameNeedUpdate = false;
					if (!flag4)
					{
						this._strategicAreaSidesScoreTally[(int)shimmyDirection] = null;
					}
					else
					{
						this._shimmyDirection = shimmyDirection;
						this._lastShimmyTime = totalMissionTime;
						Mat3 identity = Mat3.Identity;
						identity.f = new Vec3(vec3, 0f, -1f);
						identity.OrthonormalizeAccordingToForwardAndKeepUpAsZAxis();
						this._cachedWorldFrame = new WorldFrame(identity, value);
					}
					return new WorldFrame?(this._cachedWorldFrame);
				}
				MBDebug.ShowWarning(string.Concat(new object[]
				{
					"Strategic archer position at position at X=",
					this._frame.Origin.GetGroundVec3().x,
					" Y=",
					this._frame.Origin.GetGroundVec3().y,
					" Z=",
					this._frame.Origin.GetGroundVec3().z,
					"doesn't yield a viable frame. It may be in the air, underground or off the navmesh, please check. Scene: ",
					base.Scene.GetName()
				}));
				return new WorldFrame?(agent.GetWorldFrame());
			}
		}

		private static float CalculateWeight(int capacity, int index)
		{
			return (float)(capacity - index) * 1f / (float)capacity * 0.5f;
		}

		public float? GetWeightOfNextSlot(BattleSideEnum side)
		{
			if (this._agents.Count < this._capacity)
			{
				return new float?(StrategicArea.CalculateWeight(this._capacity, this._agents.Count));
			}
			return null;
		}

		public float GetWeightOfOccupiedSlot(Agent agent)
		{
			return StrategicArea.CalculateWeight(this._capacity, this._agents.IndexOf(agent));
		}

		public bool IsUsableBy(BattleSideEnum side)
		{
			return this._side == side || this._side == BattleSideEnum.None;
		}

		float IDetachment.GetDetachmentWeight(BattleSideEnum side)
		{
			if (this._agents.Count < this._capacity)
			{
				return (float)(this._capacity - this._agents.Count) * 1f / (float)this._capacity;
			}
			return float.MinValue;
		}

		void IDetachment.ResetEvaluation()
		{
			this._isEvaluated = false;
		}

		bool IDetachment.IsEvaluated()
		{
			return this._isEvaluated;
		}

		void IDetachment.SetAsEvaluated()
		{
			this._isEvaluated = true;
		}

		float IDetachment.GetDetachmentWeightFromCache()
		{
			return this._cachedDetachmentWeight;
		}

		float IDetachment.ComputeAndCacheDetachmentWeight(BattleSideEnum side)
		{
			this._cachedDetachmentWeight = ((IDetachment)this).GetDetachmentWeight(side);
			return this._cachedDetachmentWeight;
		}

		private List<Agent> _agents;

		private WorldFrame _frame;

		[EditableScriptComponentVariable(true)]
		private float _width;

		private int _unitSpacing;

		private int _capacity;

		private MBList<Formation> _userFormations;

		private Dictionary<Formation, Formation> _simulationFormations;

		[EditableScriptComponentVariable(true)]
		private BattleSideEnum _side;

		[EditableScriptComponentVariable(true)]
		private float _depth = 1f;

		[EditableScriptComponentVariable(true)]
		private float _distanceToCheck = 10f;

		[EditableScriptComponentVariable(true)]
		private bool _ignoreHeight = true;

		private List<DestructableComponent> _nearbyDestructibleObjects = new List<DestructableComponent>();

		private bool _isActive;

		private float _lastShimmyTime;

		private float _lastShootTime;

		private StrategicArea.ShimmyDirection _shimmyDirection;

		private bool _doesFrameNeedUpdate = true;

		private readonly StrategicArea.StrategicAreaMutableTuple[] _strategicAreaSidesScoreTally = new StrategicArea.StrategicAreaMutableTuple[5];

		private WorldPosition? _centerPosition;

		private WorldFrame _cachedWorldFrame;

		private bool _isEvaluated;

		private float _cachedDetachmentWeight;

		private class StrategicAreaMutableTuple
		{
			public StrategicAreaMutableTuple(int rangedHitReceivedCount, int rangedHitScoredCount)
			{
				this.RangedHitReceivedCount = rangedHitReceivedCount;
				this.RangedHitScoredCount = rangedHitScoredCount;
			}

			public int RangedHitReceivedCount;

			public int RangedHitScoredCount;
		}

		private enum ShimmyDirection
		{
			Center,
			Left,
			Forward,
			Right,
			Back,
			NumDirections
		}
	}
}
