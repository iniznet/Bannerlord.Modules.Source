using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

namespace TaleWorlds.Core
{
	// Token: 0x02000027 RID: 39
	public class CraftingTemplate : MBObjectBase
	{
		// Token: 0x06000260 RID: 608 RVA: 0x0000AB75 File Offset: 0x00008D75
		internal static void AutoGeneratedStaticCollectObjectsCraftingTemplate(object o, List<object> collectedObjects)
		{
			((CraftingTemplate)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		// Token: 0x06000261 RID: 609 RVA: 0x0000AB83 File Offset: 0x00008D83
		protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
			base.AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		// Token: 0x170000B8 RID: 184
		// (get) Token: 0x06000262 RID: 610 RVA: 0x0000AB8C File Offset: 0x00008D8C
		// (set) Token: 0x06000263 RID: 611 RVA: 0x0000AB94 File Offset: 0x00008D94
		public PieceData[] BuildOrders { get; private set; }

		// Token: 0x170000B9 RID: 185
		// (get) Token: 0x06000264 RID: 612 RVA: 0x0000AB9D File Offset: 0x00008D9D
		// (set) Token: 0x06000265 RID: 613 RVA: 0x0000ABA5 File Offset: 0x00008DA5
		public WeaponDescription[] WeaponDescriptions { get; private set; }

		// Token: 0x170000BA RID: 186
		// (get) Token: 0x06000266 RID: 614 RVA: 0x0000ABAE File Offset: 0x00008DAE
		// (set) Token: 0x06000267 RID: 615 RVA: 0x0000ABB6 File Offset: 0x00008DB6
		public List<CraftingPiece> Pieces { get; private set; }

		// Token: 0x170000BB RID: 187
		// (get) Token: 0x06000268 RID: 616 RVA: 0x0000ABBF File Offset: 0x00008DBF
		// (set) Token: 0x06000269 RID: 617 RVA: 0x0000ABC7 File Offset: 0x00008DC7
		public ItemObject.ItemTypeEnum ItemType { get; private set; }

		// Token: 0x170000BC RID: 188
		// (get) Token: 0x0600026A RID: 618 RVA: 0x0000ABD0 File Offset: 0x00008DD0
		// (set) Token: 0x0600026B RID: 619 RVA: 0x0000ABD8 File Offset: 0x00008DD8
		public ItemModifierGroup ItemModifierGroup { get; private set; }

		// Token: 0x170000BD RID: 189
		// (get) Token: 0x0600026C RID: 620 RVA: 0x0000ABE1 File Offset: 0x00008DE1
		// (set) Token: 0x0600026D RID: 621 RVA: 0x0000ABE9 File Offset: 0x00008DE9
		public string[] ItemHolsters { get; private set; }

		// Token: 0x170000BE RID: 190
		// (get) Token: 0x0600026E RID: 622 RVA: 0x0000ABF2 File Offset: 0x00008DF2
		// (set) Token: 0x0600026F RID: 623 RVA: 0x0000ABFA File Offset: 0x00008DFA
		public Vec3 ItemHolsterPositionShift { get; private set; }

		// Token: 0x170000BF RID: 191
		// (get) Token: 0x06000270 RID: 624 RVA: 0x0000AC03 File Offset: 0x00008E03
		// (set) Token: 0x06000271 RID: 625 RVA: 0x0000AC0B File Offset: 0x00008E0B
		public bool UseWeaponAsHolsterMesh { get; private set; }

		// Token: 0x170000C0 RID: 192
		// (get) Token: 0x06000272 RID: 626 RVA: 0x0000AC14 File Offset: 0x00008E14
		// (set) Token: 0x06000273 RID: 627 RVA: 0x0000AC1C File Offset: 0x00008E1C
		public bool AlwaysShowHolsterWithWeapon { get; private set; }

		// Token: 0x170000C1 RID: 193
		// (get) Token: 0x06000274 RID: 628 RVA: 0x0000AC25 File Offset: 0x00008E25
		// (set) Token: 0x06000275 RID: 629 RVA: 0x0000AC2D File Offset: 0x00008E2D
		public bool RotateWeaponInHolster { get; private set; }

		// Token: 0x170000C2 RID: 194
		// (get) Token: 0x06000276 RID: 630 RVA: 0x0000AC36 File Offset: 0x00008E36
		// (set) Token: 0x06000277 RID: 631 RVA: 0x0000AC3E File Offset: 0x00008E3E
		public CraftingPiece.PieceTypes PieceTypeToScaleHolsterWith { get; private set; }

		// Token: 0x06000279 RID: 633 RVA: 0x0000AC50 File Offset: 0x00008E50
		public int GetIndexOfUsageDataWithId(string weaponDescriptionId)
		{
			int num = -1;
			for (int i = 0; i < this.WeaponDescriptions.Length; i++)
			{
				if (weaponDescriptionId == this.WeaponDescriptions[i].StringId)
				{
					num = i;
					break;
				}
			}
			return num;
		}

		// Token: 0x0600027A RID: 634 RVA: 0x0000AC8C File Offset: 0x00008E8C
		public bool IsPieceTypeHiddenOnHolster(CraftingPiece.PieceTypes pieceType)
		{
			return this._hiddenPieceTypesOnHolsteredMesh[(int)pieceType];
		}

		// Token: 0x0600027B RID: 635 RVA: 0x0000AC96 File Offset: 0x00008E96
		public IEnumerable<KeyValuePair<CraftingTemplate.CraftingStatTypes, float>> GetStatDatas(int usageIndex, DamageTypes thrustDamageType, DamageTypes swingDamageType)
		{
			int num;
			for (int i = 0; i < this._statDataValues[usageIndex].Length; i = num + 1)
			{
				CraftingTemplate.CraftingStatTypes craftingStatTypes = (CraftingTemplate.CraftingStatTypes)i;
				bool flag = false;
				switch (craftingStatTypes)
				{
				case CraftingTemplate.CraftingStatTypes.ThrustSpeed:
				case CraftingTemplate.CraftingStatTypes.ThrustDamage:
					flag = thrustDamageType == DamageTypes.Invalid;
					break;
				case CraftingTemplate.CraftingStatTypes.SwingSpeed:
				case CraftingTemplate.CraftingStatTypes.SwingDamage:
					flag = swingDamageType == DamageTypes.Invalid;
					break;
				}
				if (!flag && this._statDataValues[usageIndex][i] >= 0f)
				{
					yield return new KeyValuePair<CraftingTemplate.CraftingStatTypes, float>(craftingStatTypes, this._statDataValues[usageIndex][i]);
				}
				num = i;
			}
			yield break;
		}

		// Token: 0x0600027C RID: 636 RVA: 0x0000ACBB File Offset: 0x00008EBB
		public override string ToString()
		{
			return this.TemplateName.ToString();
		}

		// Token: 0x0600027D RID: 637 RVA: 0x0000ACC8 File Offset: 0x00008EC8
		public bool IsPieceTypeUsable(CraftingPiece.PieceTypes pieceType)
		{
			return this.BuildOrders.Any((PieceData bO) => bO.PieceType == pieceType);
		}

		// Token: 0x0600027E RID: 638 RVA: 0x0000ACFC File Offset: 0x00008EFC
		public override void Deserialize(MBObjectManager objectManager, XmlNode node)
		{
			base.Deserialize(objectManager, node);
			this._hiddenPieceTypesOnHolsteredMesh = new bool[4];
			XmlAttribute xmlAttribute = node.Attributes["modifier_group"];
			string text = ((xmlAttribute != null) ? xmlAttribute.Value : null);
			if (text != null)
			{
				this.ItemModifierGroup = Game.Current.ObjectManager.GetObject<ItemModifierGroup>(text);
			}
			this.ItemType = (ItemObject.ItemTypeEnum)Enum.Parse(typeof(ItemObject.ItemTypeEnum), node.Attributes["item_type"].Value);
			this.ItemHolsters = node.Attributes["item_holsters"].Value.Split(new char[] { ':' });
			this.ItemHolsterPositionShift = Vec3.Parse(node.Attributes["default_item_holster_position_offset"].Value);
			this.UseWeaponAsHolsterMesh = XmlHelper.ReadBool(node, "use_weapon_as_holster_mesh");
			this.AlwaysShowHolsterWithWeapon = XmlHelper.ReadBool(node, "always_show_holster_with_weapon");
			this.RotateWeaponInHolster = XmlHelper.ReadBool(node, "rotate_weapon_in_holster");
			XmlAttribute xmlAttribute2 = node.Attributes["piece_type_to_scale_holster_with"];
			this.PieceTypeToScaleHolsterWith = ((xmlAttribute2 != null) ? ((CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), xmlAttribute2.Value)) : CraftingPiece.PieceTypes.Invalid);
			XmlAttribute xmlAttribute3 = node.Attributes["hidden_piece_types_on_holster"];
			if (xmlAttribute3 != null)
			{
				foreach (string text2 in xmlAttribute3.Value.Split(new char[] { ':' }))
				{
					CraftingPiece.PieceTypes pieceTypes = (CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), text2);
					this._hiddenPieceTypesOnHolsteredMesh[(int)pieceTypes] = true;
				}
			}
			foreach (object obj in node.ChildNodes)
			{
				XmlNode xmlNode = (XmlNode)obj;
				if (xmlNode.Attributes != null)
				{
					string name = xmlNode.Name;
					if (!(name == "PieceDatas"))
					{
						if (!(name == "WeaponDescriptions"))
						{
							if (!(name == "UsablePieces"))
							{
								if (!(name == "StatsData"))
								{
									continue;
								}
							}
							else
							{
								this.Pieces = new List<CraftingPiece>();
								using (IEnumerator enumerator2 = xmlNode.ChildNodes.GetEnumerator())
								{
									while (enumerator2.MoveNext())
									{
										object obj2 = enumerator2.Current;
										string value = ((XmlNode)obj2).Attributes["piece_id"].Value;
										CraftingPiece @object = MBObjectManager.Instance.GetObject<CraftingPiece>(value);
										if (@object != null)
										{
											this.Pieces.Add(@object);
										}
									}
									continue;
								}
							}
							XmlAttribute xmlAttribute4 = xmlNode.Attributes["weapon_description"];
							float[] array2 = new float[11];
							for (int j = 0; j < array2.Length; j++)
							{
								array2[j] = float.MinValue;
							}
							foreach (object obj3 in xmlNode.ChildNodes)
							{
								XmlNode xmlNode2 = (XmlNode)obj3;
								if (xmlNode2.NodeType == XmlNodeType.Element)
								{
									XmlAttribute xmlAttribute5 = xmlNode2.Attributes["stat_type"];
									XmlNode xmlNode3 = xmlNode2.Attributes["max_value"];
									CraftingTemplate.CraftingStatTypes craftingStatTypes = (CraftingTemplate.CraftingStatTypes)Enum.Parse(typeof(CraftingTemplate.CraftingStatTypes), xmlAttribute5.Value);
									float num = float.Parse(xmlNode3.Value);
									array2[(int)craftingStatTypes] = num;
								}
							}
							if (xmlAttribute4 != null)
							{
								int indexOfUsageDataWithId = this.GetIndexOfUsageDataWithId(xmlAttribute4.Value);
								this._statDataValues[indexOfUsageDataWithId] = array2;
							}
							else
							{
								for (int k = 0; k < this._statDataValues.Length; k++)
								{
									this._statDataValues[k] = array2;
								}
							}
						}
						else
						{
							List<WeaponDescription> list = new List<WeaponDescription>();
							foreach (object obj4 in xmlNode.ChildNodes)
							{
								string value2 = ((XmlNode)obj4).Attributes["id"].Value;
								WeaponDescription object2 = MBObjectManager.Instance.GetObject<WeaponDescription>(value2);
								if (object2 != null)
								{
									list.Add(object2);
								}
							}
							this.WeaponDescriptions = list.ToArray();
							this._statDataValues = new float[this.WeaponDescriptions.Length][];
						}
					}
					else
					{
						List<PieceData> list2 = new List<PieceData>();
						foreach (object obj5 in xmlNode.ChildNodes)
						{
							XmlNode xmlNode4 = (XmlNode)obj5;
							XmlAttribute xmlAttribute6 = xmlNode4.Attributes["piece_type"];
							XmlNode xmlNode5 = xmlNode4.Attributes["build_order"];
							CraftingPiece.PieceTypes pieceTypes2 = (CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), xmlAttribute6.Value);
							int num2 = int.Parse(xmlNode5.Value);
							list2.Add(new PieceData(pieceTypes2, num2));
						}
						this.BuildOrders = list2.ToArray();
					}
				}
			}
			this.TemplateName = GameTexts.FindText("str_crafting_template", base.StringId);
		}

		// Token: 0x170000C3 RID: 195
		// (get) Token: 0x0600027F RID: 639 RVA: 0x0000B2AC File Offset: 0x000094AC
		public static MBReadOnlyList<CraftingTemplate> All
		{
			get
			{
				return MBObjectManager.Instance.GetObjectTypeList<CraftingTemplate>();
			}
		}

		// Token: 0x06000280 RID: 640 RVA: 0x0000B2B8 File Offset: 0x000094B8
		public static CraftingTemplate GetTemplateFromId(string templateId)
		{
			return MBObjectManager.Instance.GetObject<CraftingTemplate>(templateId);
		}

		// Token: 0x0400019D RID: 413
		public TextObject TemplateName;

		// Token: 0x040001A0 RID: 416
		private bool[] _hiddenPieceTypesOnHolsteredMesh;

		// Token: 0x040001A2 RID: 418
		private float[][] _statDataValues;

		// Token: 0x020000DB RID: 219
		public enum CraftingStatTypes
		{
			// Token: 0x0400061D RID: 1565
			Weight,
			// Token: 0x0400061E RID: 1566
			WeaponReach,
			// Token: 0x0400061F RID: 1567
			ThrustSpeed,
			// Token: 0x04000620 RID: 1568
			SwingSpeed,
			// Token: 0x04000621 RID: 1569
			ThrustDamage,
			// Token: 0x04000622 RID: 1570
			SwingDamage,
			// Token: 0x04000623 RID: 1571
			Handling,
			// Token: 0x04000624 RID: 1572
			MissileDamage,
			// Token: 0x04000625 RID: 1573
			MissileSpeed,
			// Token: 0x04000626 RID: 1574
			Accuracy,
			// Token: 0x04000627 RID: 1575
			StackAmount,
			// Token: 0x04000628 RID: 1576
			NumStatTypes
		}
	}
}
