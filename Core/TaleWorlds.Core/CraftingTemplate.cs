using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

namespace TaleWorlds.Core
{
	public class CraftingTemplate : MBObjectBase
	{
		internal static void AutoGeneratedStaticCollectObjectsCraftingTemplate(object o, List<object> collectedObjects)
		{
			((CraftingTemplate)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
			base.AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		public PieceData[] BuildOrders { get; private set; }

		public WeaponDescription[] WeaponDescriptions { get; private set; }

		public List<CraftingPiece> Pieces { get; private set; }

		public ItemObject.ItemTypeEnum ItemType { get; private set; }

		public ItemModifierGroup ItemModifierGroup { get; private set; }

		public string[] ItemHolsters { get; private set; }

		public Vec3 ItemHolsterPositionShift { get; private set; }

		public bool UseWeaponAsHolsterMesh { get; private set; }

		public bool AlwaysShowHolsterWithWeapon { get; private set; }

		public bool RotateWeaponInHolster { get; private set; }

		public CraftingPiece.PieceTypes PieceTypeToScaleHolsterWith { get; private set; }

		public int GetIndexOfUsageDataWithId(string weaponDescriptionId)
		{
			int num = -1;
			for (int i = 0; i < this.WeaponDescriptions.Length; i++)
			{
				if (weaponDescriptionId == this.WeaponDescriptions[i].StringId)
				{
					num = i;
					break;
				}
			}
			return num;
		}

		public bool IsPieceTypeHiddenOnHolster(CraftingPiece.PieceTypes pieceType)
		{
			return this._hiddenPieceTypesOnHolsteredMesh[(int)pieceType];
		}

		public IEnumerable<KeyValuePair<CraftingTemplate.CraftingStatTypes, float>> GetStatDatas(int usageIndex, DamageTypes thrustDamageType, DamageTypes swingDamageType)
		{
			int num;
			for (int i = 0; i < this._statDataValues[usageIndex].Length; i = num + 1)
			{
				CraftingTemplate.CraftingStatTypes craftingStatTypes = (CraftingTemplate.CraftingStatTypes)i;
				bool flag = false;
				switch (craftingStatTypes)
				{
				case CraftingTemplate.CraftingStatTypes.ThrustSpeed:
				case CraftingTemplate.CraftingStatTypes.ThrustDamage:
					flag = thrustDamageType == DamageTypes.Invalid;
					break;
				case CraftingTemplate.CraftingStatTypes.SwingSpeed:
				case CraftingTemplate.CraftingStatTypes.SwingDamage:
					flag = swingDamageType == DamageTypes.Invalid;
					break;
				}
				if (!flag && this._statDataValues[usageIndex][i] >= 0f)
				{
					yield return new KeyValuePair<CraftingTemplate.CraftingStatTypes, float>(craftingStatTypes, this._statDataValues[usageIndex][i]);
				}
				num = i;
			}
			yield break;
		}

		public override string ToString()
		{
			return this.TemplateName.ToString();
		}

		public bool IsPieceTypeUsable(CraftingPiece.PieceTypes pieceType)
		{
			return this.BuildOrders.Any((PieceData bO) => bO.PieceType == pieceType);
		}

		public override void Deserialize(MBObjectManager objectManager, XmlNode node)
		{
			base.Deserialize(objectManager, node);
			this._hiddenPieceTypesOnHolsteredMesh = new bool[4];
			XmlAttribute xmlAttribute = node.Attributes["modifier_group"];
			string text = ((xmlAttribute != null) ? xmlAttribute.Value : null);
			if (text != null)
			{
				this.ItemModifierGroup = Game.Current.ObjectManager.GetObject<ItemModifierGroup>(text);
			}
			this.ItemType = (ItemObject.ItemTypeEnum)Enum.Parse(typeof(ItemObject.ItemTypeEnum), node.Attributes["item_type"].Value);
			this.ItemHolsters = node.Attributes["item_holsters"].Value.Split(new char[] { ':' });
			this.ItemHolsterPositionShift = Vec3.Parse(node.Attributes["default_item_holster_position_offset"].Value);
			this.UseWeaponAsHolsterMesh = XmlHelper.ReadBool(node, "use_weapon_as_holster_mesh");
			this.AlwaysShowHolsterWithWeapon = XmlHelper.ReadBool(node, "always_show_holster_with_weapon");
			this.RotateWeaponInHolster = XmlHelper.ReadBool(node, "rotate_weapon_in_holster");
			XmlAttribute xmlAttribute2 = node.Attributes["piece_type_to_scale_holster_with"];
			this.PieceTypeToScaleHolsterWith = ((xmlAttribute2 != null) ? ((CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), xmlAttribute2.Value)) : CraftingPiece.PieceTypes.Invalid);
			XmlAttribute xmlAttribute3 = node.Attributes["hidden_piece_types_on_holster"];
			if (xmlAttribute3 != null)
			{
				foreach (string text2 in xmlAttribute3.Value.Split(new char[] { ':' }))
				{
					CraftingPiece.PieceTypes pieceTypes = (CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), text2);
					this._hiddenPieceTypesOnHolsteredMesh[(int)pieceTypes] = true;
				}
			}
			foreach (object obj in node.ChildNodes)
			{
				XmlNode xmlNode = (XmlNode)obj;
				if (xmlNode.Attributes != null)
				{
					string name = xmlNode.Name;
					if (!(name == "PieceDatas"))
					{
						if (!(name == "WeaponDescriptions"))
						{
							if (!(name == "UsablePieces"))
							{
								if (!(name == "StatsData"))
								{
									continue;
								}
							}
							else
							{
								this.Pieces = new List<CraftingPiece>();
								using (IEnumerator enumerator2 = xmlNode.ChildNodes.GetEnumerator())
								{
									while (enumerator2.MoveNext())
									{
										object obj2 = enumerator2.Current;
										string value = ((XmlNode)obj2).Attributes["piece_id"].Value;
										CraftingPiece @object = MBObjectManager.Instance.GetObject<CraftingPiece>(value);
										if (@object != null)
										{
											this.Pieces.Add(@object);
										}
									}
									continue;
								}
							}
							XmlAttribute xmlAttribute4 = xmlNode.Attributes["weapon_description"];
							float[] array2 = new float[11];
							for (int j = 0; j < array2.Length; j++)
							{
								array2[j] = float.MinValue;
							}
							foreach (object obj3 in xmlNode.ChildNodes)
							{
								XmlNode xmlNode2 = (XmlNode)obj3;
								if (xmlNode2.NodeType == XmlNodeType.Element)
								{
									XmlAttribute xmlAttribute5 = xmlNode2.Attributes["stat_type"];
									XmlNode xmlNode3 = xmlNode2.Attributes["max_value"];
									CraftingTemplate.CraftingStatTypes craftingStatTypes = (CraftingTemplate.CraftingStatTypes)Enum.Parse(typeof(CraftingTemplate.CraftingStatTypes), xmlAttribute5.Value);
									float num = float.Parse(xmlNode3.Value);
									array2[(int)craftingStatTypes] = num;
								}
							}
							if (xmlAttribute4 != null)
							{
								int indexOfUsageDataWithId = this.GetIndexOfUsageDataWithId(xmlAttribute4.Value);
								this._statDataValues[indexOfUsageDataWithId] = array2;
							}
							else
							{
								for (int k = 0; k < this._statDataValues.Length; k++)
								{
									this._statDataValues[k] = array2;
								}
							}
						}
						else
						{
							List<WeaponDescription> list = new List<WeaponDescription>();
							foreach (object obj4 in xmlNode.ChildNodes)
							{
								string value2 = ((XmlNode)obj4).Attributes["id"].Value;
								WeaponDescription object2 = MBObjectManager.Instance.GetObject<WeaponDescription>(value2);
								if (object2 != null)
								{
									list.Add(object2);
								}
							}
							this.WeaponDescriptions = list.ToArray();
							this._statDataValues = new float[this.WeaponDescriptions.Length][];
						}
					}
					else
					{
						List<PieceData> list2 = new List<PieceData>();
						foreach (object obj5 in xmlNode.ChildNodes)
						{
							XmlNode xmlNode4 = (XmlNode)obj5;
							XmlAttribute xmlAttribute6 = xmlNode4.Attributes["piece_type"];
							XmlNode xmlNode5 = xmlNode4.Attributes["build_order"];
							CraftingPiece.PieceTypes pieceTypes2 = (CraftingPiece.PieceTypes)Enum.Parse(typeof(CraftingPiece.PieceTypes), xmlAttribute6.Value);
							int num2 = int.Parse(xmlNode5.Value);
							list2.Add(new PieceData(pieceTypes2, num2));
						}
						this.BuildOrders = list2.ToArray();
					}
				}
			}
			this.TemplateName = GameTexts.FindText("str_crafting_template", base.StringId);
		}

		public static MBReadOnlyList<CraftingTemplate> All
		{
			get
			{
				return MBObjectManager.Instance.GetObjectTypeList<CraftingTemplate>();
			}
		}

		public static CraftingTemplate GetTemplateFromId(string templateId)
		{
			return MBObjectManager.Instance.GetObject<CraftingTemplate>(templateId);
		}

		public TextObject TemplateName;

		private bool[] _hiddenPieceTypesOnHolsteredMesh;

		private float[][] _statDataValues;

		public enum CraftingStatTypes
		{
			Weight,
			WeaponReach,
			ThrustSpeed,
			SwingSpeed,
			ThrustDamage,
			SwingDamage,
			Handling,
			MissileDamage,
			MissileSpeed,
			Accuracy,
			StackAmount,
			NumStatTypes
		}
	}
}
