using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using TaleWorlds.Library;

namespace TaleWorlds.Core
{
	public class EntitySystem<T> where T : class, IEntityComponent
	{
		protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
		}

		public MBReadOnlyList<T> Components
		{
			get
			{
				return this._components;
			}
		}

		public EntitySystem()
		{
			this._components = new MBList<T>();
			this._componentsOfTypes = new Dictionary<Type, IList>();
		}

		public TComponent AddComponent<TComponent>() where TComponent : class, T, new()
		{
			return this.AddComponent(typeof(TComponent)) as TComponent;
		}

		public T AddComponent(Type componentType)
		{
			T t = componentType.GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Type[0], null).Invoke(new object[0]) as T;
			this._components.Add(t);
			Type type = t.GetType();
			while (type != null && type != typeof(object))
			{
				if (!this._componentsOfTypes.ContainsKey(type))
				{
					IList list = Activator.CreateInstance(typeof(List<>).MakeGenericType(new Type[] { type })) as IList;
					this._componentsOfTypes.Add(type, list);
				}
				this._componentsOfTypes[type].Add(t);
				type = type.BaseType;
			}
			t.OnInitialize();
			return t;
		}

		public TComponent GetComponent<TComponent>() where TComponent : class, T
		{
			if (this._componentsOfTypes.ContainsKey(typeof(TComponent)))
			{
				IList list = this._componentsOfTypes[typeof(TComponent)];
				if (list.Count > 0)
				{
					return list[0] as TComponent;
				}
			}
			return default(TComponent);
		}

		public T GetComponent(Type componentType)
		{
			if (this._componentsOfTypes.ContainsKey(componentType))
			{
				IList list = this._componentsOfTypes[componentType];
				if (list.Count > 0)
				{
					return list[0] as T;
				}
			}
			return default(T);
		}

		public List<TComponent> GetComponents<TComponent>() where TComponent : class, T
		{
			if (this._componentsOfTypes.ContainsKey(typeof(TComponent)))
			{
				IList list = this._componentsOfTypes[typeof(TComponent)];
				if (list.Count > 0)
				{
					return list as List<TComponent>;
				}
			}
			return null;
		}

		public MBList<T> GetComponents()
		{
			return this._components;
		}

		public void RemoveComponent(T component)
		{
			component.OnFinalize();
			this._components.Remove(component);
			Type type = component.GetType();
			while (type != null && type != typeof(object))
			{
				this._componentsOfTypes[type].Remove(component);
				type = type.BaseType;
			}
		}

		public void RemoveComponent<TComponent>() where TComponent : class, T
		{
			TComponent component = this.GetComponent<TComponent>();
			if (component != null)
			{
				this.RemoveComponent((T)((object)component));
			}
		}

		private readonly MBList<T> _components;

		private readonly Dictionary<Type, IList> _componentsOfTypes;
	}
}
