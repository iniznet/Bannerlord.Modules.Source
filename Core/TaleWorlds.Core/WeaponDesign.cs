using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core
{
	public class WeaponDesign
	{
		internal static void AutoGeneratedStaticCollectObjectsWeaponDesign(object o, List<object> collectedObjects)
		{
			((WeaponDesign)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
			collectedObjects.Add(this.Template);
			collectedObjects.Add(this.TopPivotOffsets);
			collectedObjects.Add(this.BottomPivotOffsets);
			collectedObjects.Add(this._usedPieces);
			collectedObjects.Add(this._piecePivotDistances);
			collectedObjects.Add(this.WeaponName);
		}

		internal static object AutoGeneratedGetMemberValueWeaponName(object o)
		{
			return ((WeaponDesign)o).WeaponName;
		}

		internal static object AutoGeneratedGetMemberValueHandToBottomLength(object o)
		{
			return ((WeaponDesign)o).HandToBottomLength;
		}

		internal static object AutoGeneratedGetMemberValueWeaponFlags(object o)
		{
			return ((WeaponDesign)o).WeaponFlags;
		}

		internal static object AutoGeneratedGetMemberValueCraftedWeaponLength(object o)
		{
			return ((WeaponDesign)o).CraftedWeaponLength;
		}

		internal static object AutoGeneratedGetMemberValueTemplate(object o)
		{
			return ((WeaponDesign)o).Template;
		}

		internal static object AutoGeneratedGetMemberValueTopPivotOffsets(object o)
		{
			return ((WeaponDesign)o).TopPivotOffsets;
		}

		internal static object AutoGeneratedGetMemberValueBottomPivotOffsets(object o)
		{
			return ((WeaponDesign)o).BottomPivotOffsets;
		}

		internal static object AutoGeneratedGetMemberValueHolsterShiftAmount(object o)
		{
			return ((WeaponDesign)o).HolsterShiftAmount;
		}

		internal static object AutoGeneratedGetMemberValue_usedPieces(object o)
		{
			return ((WeaponDesign)o)._usedPieces;
		}

		internal static object AutoGeneratedGetMemberValue_piecePivotDistances(object o)
		{
			return ((WeaponDesign)o)._piecePivotDistances;
		}

		[SaveableProperty(21)]
		public TextObject WeaponName { get; private set; }

		public WeaponDesignElement[] UsedPieces
		{
			get
			{
				return this._usedPieces;
			}
		}

		public string HashedCode
		{
			get
			{
				return this._hashedCode;
			}
		}

		public float[] PiecePivotDistances
		{
			get
			{
				return this._piecePivotDistances;
			}
		}

		public float TotalLength
		{
			get
			{
				return this.CraftedWeaponLength + this.HandToBottomLength;
			}
		}

		[SaveableProperty(50)]
		public float HandToBottomLength { get; private set; }

		public float BottomPivotOffset
		{
			get
			{
				return this.BottomPivotOffsets[this.BottomPivotOffsets.Count - 1];
			}
		}

		public WeaponDesign(CraftingTemplate template, TextObject weaponName, WeaponDesignElement[] usedPieces)
		{
			this.Template = template;
			this._usedPieces = usedPieces.ToArray<WeaponDesignElement>();
			this.WeaponName = weaponName;
			this._piecePivotDistances = new float[usedPieces.Length];
			this.CalculatePivotDistances();
			this.CraftedWeaponLength = this.CalculateWeaponLength();
			this.HolsterShiftAmount = this.CalculateHolsterShiftAmount();
			foreach (WeaponDesignElement weaponDesignElement in usedPieces)
			{
				this.WeaponFlags |= weaponDesignElement.CraftingPiece.AdditionalWeaponFlags;
			}
			this.BuildHashedCode();
		}

		[LoadInitializationCallback]
		private void OnLoad()
		{
			this.BuildHashedCode();
		}

		private void CalculatePivotDistances()
		{
			float num = 0f;
			float num2 = 0f;
			foreach (PieceData pieceData in this.Template.BuildOrders)
			{
				WeaponDesignElement weaponDesignElement = this.UsedPieces[(int)pieceData.PieceType];
				if (weaponDesignElement == null || !weaponDesignElement.IsValid)
				{
					this._piecePivotDistances[(int)pieceData.PieceType] = float.NaN;
				}
				else
				{
					int num3 = MathF.Sign(pieceData.Order);
					if (num3 == 0)
					{
						num2 += weaponDesignElement.ScaledPieceOffset;
						num -= weaponDesignElement.ScaledPieceOffset;
					}
					else if (num3 < 0)
					{
						num += weaponDesignElement.ScaledDistanceToNextPiece;
						num += weaponDesignElement.ScaledPieceOffset;
						num -= weaponDesignElement.ScaledNextPieceOffset;
					}
					else if (num3 > 0)
					{
						num2 += weaponDesignElement.ScaledDistanceToPreviousPiece;
						num2 += weaponDesignElement.ScaledPieceOffset;
						num2 -= weaponDesignElement.ScaledPreviousPieceOffset;
					}
					this._piecePivotDistances[(int)pieceData.PieceType] = (float)num3 * ((num3 < 0) ? num : num2) + ((num3 == 0) ? weaponDesignElement.ScaledPieceOffset : 0f);
					this.AddTopPivotOffset(num2);
					this.AddBottomPivotOffset(num);
					if (num3 == 0)
					{
						num += weaponDesignElement.ScaledDistanceToPreviousPiece - weaponDesignElement.ScaledPreviousPieceOffset;
						num2 += weaponDesignElement.ScaledDistanceToNextPiece - weaponDesignElement.ScaledNextPieceOffset;
					}
					if (num3 < 0)
					{
						num += weaponDesignElement.ScaledDistanceToPreviousPiece - weaponDesignElement.ScaledPreviousPieceOffset;
					}
					if (num3 > 0)
					{
						num2 += weaponDesignElement.ScaledDistanceToNextPiece - weaponDesignElement.ScaledNextPieceOffset;
					}
				}
			}
			this.AddTopPivotOffset(num2);
			this.AddBottomPivotOffset(num);
			this.HandToBottomLength = num;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			WeaponDesign weaponDesign = obj as WeaponDesign;
			return weaponDesign != null && this.HashedCode == weaponDesign.HashedCode && this.WeaponName == weaponDesign.WeaponName;
		}

		public override int GetHashCode()
		{
			return this._cachedHashedCodeInt;
		}

		public static bool operator ==(WeaponDesign x, WeaponDesign y)
		{
			bool flag = x == null;
			bool flag2 = y == null;
			return (flag && flag2) || (!flag && x.Equals(y));
		}

		public static bool operator !=(WeaponDesign x, WeaponDesign y)
		{
			return !(x == y);
		}

		private void AddTopPivotOffset(float offset)
		{
			if (this.TopPivotOffsets == null)
			{
				this.TopPivotOffsets = new List<float>();
			}
			this.TopPivotOffsets.Add(offset);
		}

		private void AddBottomPivotOffset(float offset)
		{
			if (this.BottomPivotOffsets == null)
			{
				this.BottomPivotOffsets = new List<float>();
			}
			this.BottomPivotOffsets.Add(offset);
		}

		private Vec3 CalculateHolsterShiftAmount()
		{
			WeaponDesignElement weaponDesignElement = this.UsedPieces[2];
			Vec3 vec = (this.Template.ItemHolsterPositionShift + weaponDesignElement.CraftingPiece.ItemHolsterPosShift) * weaponDesignElement.ScaleFactor;
			if (this.UsedPieces[1] != null)
			{
				vec += Vec3.Up * this.UsedPieces[1].ScaledLength;
			}
			return vec;
		}

		private float CalculateWeaponLength()
		{
			int num = 0;
			float num2 = this._piecePivotDistances[num] + this._usedPieces[num].ScaledDistanceToNextPiece;
			float num3 = 0f;
			foreach (WeaponDesignElement weaponDesignElement in this._usedPieces)
			{
				if (weaponDesignElement.IsValid && weaponDesignElement.ScaledDistanceToNextPiece > num3)
				{
					float scaledPieceOffset = weaponDesignElement.ScaledPieceOffset;
					num3 = weaponDesignElement.ScaledDistanceToNextPiece + scaledPieceOffset;
				}
			}
			return MathF.Max(num2, num3);
		}

		private void BuildHashedCode()
		{
			string text = "";
			foreach (WeaponDesignElement weaponDesignElement in this.UsedPieces)
			{
				if (weaponDesignElement.IsValid)
				{
					text = string.Concat(new object[]
					{
						text,
						weaponDesignElement.CraftingPiece.StringId,
						";",
						weaponDesignElement.ScalePercentage,
						";"
					});
				}
				else
				{
					text += "invalid_piece;";
				}
			}
			text += this.Template.StringId;
			text += this.WeaponName;
			this._hashedCode = Common.CalculateMD5Hash(text);
			this._cachedHashedCodeInt = Common.GetDJB2(this._hashedCode);
		}

		[SaveableField(10)]
		public readonly WeaponFlags WeaponFlags;

		[SaveableField(30)]
		private readonly WeaponDesignElement[] _usedPieces;

		[CachedData]
		private int _cachedHashedCodeInt;

		[CachedData]
		private string _hashedCode;

		[SaveableField(40)]
		private readonly float[] _piecePivotDistances;

		[SaveableField(60)]
		public readonly float CraftedWeaponLength;

		[SaveableField(70)]
		public readonly CraftingTemplate Template;

		[SaveableField(80)]
		public List<float> TopPivotOffsets;

		[SaveableField(90)]
		public List<float> BottomPivotOffsets;

		[SaveableField(100)]
		public readonly Vec3 HolsterShiftAmount;
	}
}
