using System;
using System.Collections.Generic;
using System.Linq;
using Helpers;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.ComponentInterfaces;
using TaleWorlds.CampaignSystem.Encounters;
using TaleWorlds.CampaignSystem.Map;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Roster;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.CampaignSystem.Siege;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.LinQuick;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;
using TaleWorlds.SaveSystem;
using TaleWorlds.SaveSystem.Load;

namespace TaleWorlds.CampaignSystem.MapEvents
{
	public sealed class MapEvent : MBObjectBase, IMapEntity
	{
		internal static void AutoGeneratedStaticCollectObjectsMapEvent(object o, List<object> collectedObjects)
		{
			((MapEvent)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
			base.AutoGeneratedInstanceCollectObjects(collectedObjects);
			collectedObjects.Add(this.StrengthOfSide);
			collectedObjects.Add(this._sides);
			CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(this._nextSimulationTime, collectedObjects);
			CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(this._mapEventStartTime, collectedObjects);
			collectedObjects.Add(this.Component);
			collectedObjects.Add(this.MapEventSettlement);
		}

		internal static object AutoGeneratedGetMemberValueComponent(object o)
		{
			return ((MapEvent)o).Component;
		}

		internal static object AutoGeneratedGetMemberValueMapEventSettlement(object o)
		{
			return ((MapEvent)o).MapEventSettlement;
		}

		internal static object AutoGeneratedGetMemberValuePosition(object o)
		{
			return ((MapEvent)o).Position;
		}

		internal static object AutoGeneratedGetMemberValueIsInvulnerable(object o)
		{
			return ((MapEvent)o).IsInvulnerable;
		}

		internal static object AutoGeneratedGetMemberValueIsPlayerSimulation(object o)
		{
			return ((MapEvent)o).IsPlayerSimulation;
		}

		internal static object AutoGeneratedGetMemberValueStrengthOfSide(object o)
		{
			return ((MapEvent)o).StrengthOfSide;
		}

		internal static object AutoGeneratedGetMemberValue_state(object o)
		{
			return ((MapEvent)o)._state;
		}

		internal static object AutoGeneratedGetMemberValue_sides(object o)
		{
			return ((MapEvent)o)._sides;
		}

		internal static object AutoGeneratedGetMemberValue_mapEventUpdateCount(object o)
		{
			return ((MapEvent)o)._mapEventUpdateCount;
		}

		internal static object AutoGeneratedGetMemberValue_nextSimulationTime(object o)
		{
			return ((MapEvent)o)._nextSimulationTime;
		}

		internal static object AutoGeneratedGetMemberValue_mapEventStartTime(object o)
		{
			return ((MapEvent)o)._mapEventStartTime;
		}

		internal static object AutoGeneratedGetMemberValue_mapEventType(object o)
		{
			return ((MapEvent)o)._mapEventType;
		}

		internal static object AutoGeneratedGetMemberValue_isVisible(object o)
		{
			return ((MapEvent)o)._isVisible;
		}

		internal static object AutoGeneratedGetMemberValueFirstUpdateIsDone(object o)
		{
			return ((MapEvent)o).FirstUpdateIsDone;
		}

		internal static object AutoGeneratedGetMemberValue_battleState(object o)
		{
			return ((MapEvent)o)._battleState;
		}

		public static MapEvent PlayerMapEvent
		{
			get
			{
				MobileParty mainParty = MobileParty.MainParty;
				if (mainParty == null)
				{
					return null;
				}
				return mainParty.MapEvent;
			}
		}

		public BattleSideEnum PlayerSide
		{
			get
			{
				return PartyBase.MainParty.Side;
			}
		}

		internal IBattleObserver BattleObserver { get; set; }

		[SaveableProperty(105)]
		public MapEventComponent Component { get; private set; }

		public MapEventState State
		{
			get
			{
				return this._state;
			}
			private set
			{
				if (this._state != value)
				{
					if (this.IsPlayerMapEvent)
					{
						Debug.Print("Player MapEvent State: " + value.ToString(), 0, Debug.DebugColor.White, 17592186044416UL);
					}
					this._state = value;
				}
			}
		}

		public void BeginWait()
		{
			this.State = MapEventState.Wait;
		}

		public MapEventSide AttackerSide
		{
			get
			{
				return this._sides[1];
			}
		}

		public MapEventSide DefenderSide
		{
			get
			{
				return this._sides[0];
			}
		}

		public MapEventSide GetMapEventSide(BattleSideEnum side)
		{
			return this._sides[(int)side];
		}

		internal TroopRoster GetMemberRosterReceivingLootShare(PartyBase party)
		{
			return this._sides[(int)party.Side].MemberRosterForPlayerLootShare(party);
		}

		internal TroopRoster GetPrisonerRosterReceivingLootShare(PartyBase party)
		{
			return this._sides[(int)party.Side].PrisonerRosterForPlayerLootShare(party);
		}

		internal ItemRoster GetItemRosterReceivingLootShare(PartyBase party)
		{
			return this._sides[(int)party.Side].ItemRosterForPlayerLootShare(party);
		}

		public MBReadOnlyList<MapEventParty> PartiesOnSide(BattleSideEnum side)
		{
			return this._sides[(int)side].Parties;
		}

		public IEnumerable<PartyBase> InvolvedParties
		{
			get
			{
				foreach (MapEventSide mapEventSide in this._sides)
				{
					foreach (MapEventParty mapEventParty in mapEventSide.Parties)
					{
						yield return mapEventParty.Party;
					}
					List<MapEventParty>.Enumerator enumerator = default(List<MapEventParty>.Enumerator);
				}
				MapEventSide[] array = null;
				yield break;
				yield break;
			}
		}

		[SaveableProperty(103)]
		public Settlement MapEventSettlement { get; private set; }

		internal bool AttackersRanAway { get; private set; }

		public void GetBattleRewards(PartyBase party, out float renownChange, out float influenceChange, out float moraleChange, out float goldChange, out float playerEarnedLootPercentage)
		{
			renownChange = 0f;
			influenceChange = 0f;
			moraleChange = 0f;
			goldChange = 0f;
			playerEarnedLootPercentage = 0f;
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				foreach (MapEventParty mapEventParty in sides[i].Parties)
				{
					if (party == mapEventParty.Party)
					{
						renownChange = mapEventParty.GainedRenown;
						influenceChange = mapEventParty.GainedInfluence;
						moraleChange = mapEventParty.MoraleChange;
						goldChange = (float)(mapEventParty.PlunderedGold - mapEventParty.GoldLost);
						float num = (float)this.GetMapEventSide(mapEventParty.Party.Side).CalculateTotalContribution();
						playerEarnedLootPercentage = (float)((int)(100f * ((float)mapEventParty.ContributionToBattle / num)));
					}
				}
			}
		}

		[SaveableProperty(111)]
		public Vec2 Position { get; private set; }

		public MapEvent.BattleTypes EventType
		{
			get
			{
				return this._mapEventType;
			}
		}

		public TerrainType EventTerrainType
		{
			get
			{
				return this._eventTerrainType;
			}
		}

		[SaveableProperty(113)]
		public bool IsInvulnerable { get; set; }

		public bool IsFieldBattle
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.FieldBattle;
			}
		}

		public bool IsRaid
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.Raid;
			}
		}

		public bool IsForcingVolunteers
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.IsForcingVolunteers;
			}
		}

		public bool IsForcingSupplies
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.IsForcingSupplies;
			}
		}

		public bool IsSiegeAssault
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.Siege;
			}
		}

		public bool IsHideoutBattle
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.Hideout;
			}
		}

		public bool IsSallyOut
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.SallyOut;
			}
		}

		public bool IsSiegeOutside
		{
			get
			{
				return this._mapEventType == MapEvent.BattleTypes.SiegeOutside;
			}
		}

		public bool IsSiegeAmbush
		{
			get
			{
				return this.Component is SiegeAmbushEventComponent;
			}
		}

		internal MapEvent()
		{
			this.MapEventVisual = Campaign.Current.VisualCreator.CreateMapEventVisual(this);
		}

		[LateLoadInitializationCallback]
		private void OnLateLoad(MetaData metaData, ObjectLoadData objectLoadData)
		{
			if (this.Component == null && MBSaveLoad.IsUpdatingGameVersion && MBSaveLoad.LastLoadedGameVersion < ApplicationVersion.FromString("v1.1.0", 27066))
			{
				if (this._mapEventType == MapEvent.BattleTypes.Raid)
				{
					float num = (float)objectLoadData.GetMemberValueBySaveId(109);
					int num2 = (int)objectLoadData.GetMemberValueBySaveId(112);
					float num3 = (float)objectLoadData.GetMemberValueBySaveId(115);
					this.Component = RaidEventComponent.CreateComponentForOldSaves(this, num, num2, num3);
				}
				else if (this._mapEventType == MapEvent.BattleTypes.IsForcingSupplies)
				{
					this.Component = ForceSuppliesEventComponent.CreateComponentForOldSaves(this);
				}
				else if (this._mapEventType == MapEvent.BattleTypes.IsForcingVolunteers)
				{
					this.Component = ForceVolunteersEventComponent.CreateComponentForOldSaves(this);
				}
				else if (this._mapEventType == MapEvent.BattleTypes.IsForcingVolunteers)
				{
					this.Component = HideoutEventComponent.CreateComponentForOldSaves(this);
				}
				else if (this._mapEventType == MapEvent.BattleTypes.FieldBattle)
				{
					this.Component = FieldBattleEventComponent.CreateComponentForOldSaves(this);
				}
			}
			MapEventComponent component = this.Component;
			if (component == null)
			{
				return;
			}
			component.AfterLoad(this);
		}

		internal void OnAfterLoad()
		{
			this.CacheSimulationData();
			this._eventTerrainType = Campaign.Current.MapSceneWrapper.GetFaceTerrainType(Campaign.Current.MapSceneWrapper.GetFaceIndex(this.Position));
			if (!PartyBase.IsPositionOkForTraveling(this.Position))
			{
				Vec2 vec = this.CalculateMapEventPosition(this.AttackerSide.LeaderParty, this.DefenderSide.LeaderParty);
				if (vec != this.Position)
				{
					Vec2 vec2 = vec - this.Position;
					foreach (PartyBase partyBase in this.InvolvedParties)
					{
						if (partyBase.IsMobile && partyBase.MobileParty.EventPositionAdder.IsNonZero())
						{
							partyBase.MobileParty.EventPositionAdder += vec2;
						}
					}
					this.Position = vec;
				}
			}
			if (!this.IsFinalized)
			{
				this.MapEventVisual = Campaign.Current.VisualCreator.CreateMapEventVisual(this);
				this.MapEventVisual.Initialize(this.Position, this.GetBattleSizeValue(), this.AttackerSide.LeaderParty != PartyBase.MainParty && this.DefenderSide.LeaderParty != PartyBase.MainParty, this.IsVisible);
			}
			if (MBSaveLoad.IsUpdatingGameVersion && MBSaveLoad.LastLoadedGameVersion < ApplicationVersion.FromString("v1.2.0", 27066))
			{
				if (!this.AttackerSide.Parties.Any<MapEventParty>() || !this.DefenderSide.Parties.Any<MapEventParty>())
				{
					if (this.InvolvedParties.ContainsQ(PlayerEncounter.EncounteredParty))
					{
						PlayerEncounter.Finish(true);
					}
					this.FinalizeEvent();
				}
				if (this.MapEventSettlement != null)
				{
					if (this.IsRaid && this.MapEventSettlement.Party.MapEvent == null)
					{
						this.FinalizeEvent();
						return;
					}
					if (this.EventType == MapEvent.BattleTypes.Siege && this.MapEventSettlement.SiegeEvent == null)
					{
						this.FinalizeEvent();
					}
				}
			}
		}

		internal void Initialize(PartyBase attackerParty, PartyBase defenderParty, MapEventComponent component = null, MapEvent.BattleTypes mapEventType = MapEvent.BattleTypes.None)
		{
			this.Component = component;
			this.FirstUpdateIsDone = false;
			this.AttackersRanAway = false;
			this.MapEventSettlement = null;
			this._mapEventType = mapEventType;
			this._mapEventUpdateCount = 0;
			this._sides[0] = new MapEventSide(this, BattleSideEnum.Defender, defenderParty);
			this._sides[1] = new MapEventSide(this, BattleSideEnum.Attacker, attackerParty);
			if (attackerParty.MobileParty == MobileParty.MainParty || defenderParty.MobileParty == MobileParty.MainParty)
			{
				if (mapEventType == MapEvent.BattleTypes.Raid)
				{
					Debug.Print("A raid mapEvent has been started on " + defenderParty.Name + "\n", 0, Debug.DebugColor.DarkGreen, 64UL);
				}
				else if (defenderParty.IsSettlement && defenderParty.Settlement.IsFortification)
				{
					Debug.Print("A siege mapEvent has been started on " + defenderParty.Name + "\n", 0, Debug.DebugColor.DarkCyan, 64UL);
				}
			}
			if (attackerParty.IsMobile && attackerParty.MobileParty.CurrentSettlement != null)
			{
				this.MapEventSettlement = attackerParty.MobileParty.CurrentSettlement;
			}
			else if (defenderParty.IsMobile && defenderParty.MobileParty.CurrentSettlement != null)
			{
				this.MapEventSettlement = defenderParty.MobileParty.CurrentSettlement;
			}
			else if ((!attackerParty.IsMobile || attackerParty.MobileParty.BesiegedSettlement == null) && defenderParty.IsMobile)
			{
				Settlement besiegedSettlement = defenderParty.MobileParty.BesiegedSettlement;
			}
			if (attackerParty.IsSettlement)
			{
				this.MapEventSettlement = attackerParty.Settlement;
			}
			else if (defenderParty.IsSettlement)
			{
				this.MapEventSettlement = defenderParty.Settlement;
				this.MapEventSettlement.LastAttackerParty = attackerParty.MobileParty;
			}
			if (this.IsFieldBattle)
			{
				this.MapEventSettlement = null;
				if (attackerParty == PartyBase.MainParty || defenderParty == PartyBase.MainParty)
				{
					Settlement settlement = SettlementHelper.FindNearestVillage((Settlement x) => x.Position2D.DistanceSquared(attackerParty.Position2D) < 9f, null);
					if (settlement != null)
					{
						this.MapEventSettlement = settlement;
					}
				}
			}
			this.Position = this.CalculateMapEventPosition(attackerParty, defenderParty);
			this._eventTerrainType = Campaign.Current.MapSceneWrapper.GetFaceTerrainType(Campaign.Current.MapSceneWrapper.GetFaceIndex(this.Position));
			this.CacheSimulationData();
			attackerParty.MapEventSide = this.AttackerSide;
			defenderParty.MapEventSide = this.DefenderSide;
			if (this.MapEventSettlement != null && (mapEventType == MapEvent.BattleTypes.Siege || mapEventType == MapEvent.BattleTypes.SiegeOutside || mapEventType == MapEvent.BattleTypes.SallyOut || this.IsSiegeAmbush))
			{
				foreach (PartyBase partyBase in this.MapEventSettlement.SiegeEvent.BesiegerCamp.GetInvolvedPartiesForEventType(mapEventType))
				{
					if (partyBase.MapEventSide == null && (partyBase != PartyBase.MainParty || partyBase.MobileParty.Army != null) && (partyBase.MobileParty.Army == null || partyBase.MobileParty.Army.LeaderParty == partyBase.MobileParty))
					{
						partyBase.MapEventSide = ((mapEventType == MapEvent.BattleTypes.SallyOut) ? defenderParty.MapEventSide : attackerParty.MapEventSide);
					}
				}
			}
			if (defenderParty.IsMobile && defenderParty.MobileParty.BesiegedSettlement != null)
			{
				List<PartyBase> involvedPartiesForEventType = defenderParty.MobileParty.SiegeEvent.GetInvolvedPartiesForEventType(this._mapEventType);
				PartyBase partyBase2 = (this.IsSiegeAssault ? attackerParty : defenderParty);
				foreach (PartyBase partyBase3 in involvedPartiesForEventType)
				{
					if (partyBase3 != partyBase2 && partyBase3.IsMobile && partyBase3 != PartyBase.MainParty && partyBase3.MobileParty.BesiegedSettlement == defenderParty.MobileParty.BesiegedSettlement && (partyBase3.MobileParty.Army == null || partyBase3.MobileParty.Army.LeaderParty == partyBase3.MobileParty))
					{
						partyBase3.MapEventSide = this.DefenderSide;
					}
				}
			}
			this.State = MapEventState.Wait;
			this._mapEventStartTime = CampaignTime.Now;
			this._nextSimulationTime = MapEvent.CalculateNextSimulationTime();
			MapEventComponent component2 = this.Component;
			if (component2 != null)
			{
				component2.InitializeComponent();
			}
			if (this.MapEventSettlement != null)
			{
				this.AddInsideSettlementParties(this.MapEventSettlement);
			}
			this.MapEventVisual.Initialize(this.Position, this.GetBattleSizeValue(), this.AttackerSide.LeaderParty != PartyBase.MainParty && this.DefenderSide.LeaderParty != PartyBase.MainParty, this.IsVisible);
			this.BattleState = BattleState.None;
			CampaignEventDispatcher.Instance.OnMapEventStarted(this, attackerParty, defenderParty);
		}

		private Vec2 CalculateMapEventPosition(PartyBase attackerParty, PartyBase defenderParty)
		{
			Vec2 vec;
			if (defenderParty.IsSettlement)
			{
				vec = defenderParty.Position2D;
			}
			else
			{
				vec = attackerParty.Position2D + defenderParty.Position2D;
				vec = new Vec2(vec.x / 2f, vec.y / 2f);
			}
			return vec;
		}

		internal bool IsWinnerSide(BattleSideEnum side)
		{
			return (this.BattleState == BattleState.DefenderVictory && side == BattleSideEnum.Defender) || (this.BattleState == BattleState.AttackerVictory && side == BattleSideEnum.Attacker);
		}

		private void AddInsideSettlementParties(Settlement relatedSettlement)
		{
			List<PartyBase> list = new List<PartyBase>();
			foreach (PartyBase partyBase in relatedSettlement.GetInvolvedPartiesForEventType(this._mapEventType))
			{
				if (partyBase != PartyBase.MainParty)
				{
					MobileParty mobileParty = partyBase.MobileParty;
					if (((mobileParty != null) ? mobileParty.AttachedTo : null) != MobileParty.MainParty)
					{
						list.Add(partyBase);
					}
				}
			}
			foreach (PartyBase partyBase2 in list)
			{
				if (this.MapEventSettlement.SiegeEvent != null)
				{
					if (this.MapEventSettlement.SiegeEvent.CanPartyJoinSide(partyBase2, BattleSideEnum.Defender))
					{
						if (this.IsSallyOut)
						{
							partyBase2.MapEventSide = this.AttackerSide;
						}
						else
						{
							partyBase2.MapEventSide = this.DefenderSide;
						}
					}
					else if (partyBase2.MobileParty != null && !partyBase2.MobileParty.IsGarrison && !partyBase2.MobileParty.IsMilitia)
					{
						LeaveSettlementAction.ApplyForParty(partyBase2.MobileParty);
						partyBase2.MobileParty.Ai.SetMoveModeHold();
					}
				}
				else if (this.CanPartyJoinBattle(partyBase2, BattleSideEnum.Defender))
				{
					partyBase2.MapEventSide = this.DefenderSide;
				}
				else if (this.CanPartyJoinBattle(partyBase2, BattleSideEnum.Attacker))
				{
					partyBase2.MapEventSide = this.AttackerSide;
				}
				else if (partyBase2.MobileParty != null && !partyBase2.MobileParty.IsGarrison && !partyBase2.MobileParty.IsMilitia)
				{
					LeaveSettlementAction.ApplyForParty(partyBase2.MobileParty);
				}
			}
		}

		private int GetBattleSizeValue()
		{
			if (this.IsSiegeAssault)
			{
				return 4;
			}
			int numberOfInvolvedMen = this.GetNumberOfInvolvedMen();
			if (numberOfInvolvedMen < 30)
			{
				return 0;
			}
			if (numberOfInvolvedMen < 80)
			{
				return 1;
			}
			if (numberOfInvolvedMen >= 120)
			{
				return 3;
			}
			return 2;
		}

		private static CampaignTime CalculateNextSimulationTime()
		{
			return CampaignTime.Now + CampaignTime.Minutes(30L);
		}

		internal void AddInvolvedPartyInternal(PartyBase involvedParty, BattleSideEnum side)
		{
			if (involvedParty.LeaderHero != null && involvedParty.LeaderHero.Clan == Clan.PlayerClan && involvedParty != PartyBase.MainParty && side == BattleSideEnum.Defender && this.AttackerSide.LeaderParty != null)
			{
				bool flag = false;
				using (IEnumerator<PartyBase> enumerator = this.InvolvedParties.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						if (enumerator.Current == PartyBase.MainParty)
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag)
				{
					Settlement settlement = Hero.MainHero.HomeSettlement;
					float num = Campaign.MapDiagonalSquared;
					foreach (Settlement settlement2 in Settlement.All)
					{
						if (settlement2.IsVillage || settlement2.IsFortification)
						{
							float num2 = settlement2.Position2D.DistanceSquared(involvedParty.Position2D);
							if (num2 < num)
							{
								num = num2;
								settlement = settlement2;
							}
						}
					}
					if (settlement != null)
					{
						TextObject textObject = GameTexts.FindText("str_party_attacked", null);
						textObject.SetTextVariable("CLAN_PARTY_NAME", involvedParty.Name);
						textObject.SetTextVariable("ENEMY_PARTY_NAME", this.AttackerSide.LeaderParty.Name);
						textObject.SetTextVariable("SETTLEMENT_NAME", settlement.Name);
						MBInformationManager.AddQuickInformation(textObject, 0, null, "");
					}
				}
			}
			if (this.IsSiegeAssault && involvedParty.MobileParty != null && involvedParty.MobileParty.CurrentSettlement == null && side == BattleSideEnum.Defender)
			{
				this._mapEventType = MapEvent.BattleTypes.SiegeOutside;
			}
			if (involvedParty.MobileParty != null && involvedParty.MobileParty.IsGarrison && side == BattleSideEnum.Attacker && this.IsSiegeOutside)
			{
				this._mapEventType = MapEvent.BattleTypes.SallyOut;
				this.MapEventSettlement = involvedParty.MobileParty.CurrentSettlement;
			}
			involvedParty.ResetTempXp();
			if (involvedParty == MobileParty.MainParty.Party && !this.IsSiegeAssault && !this.IsRaid)
			{
				involvedParty.MobileParty.Ai.SetMoveModeHold();
			}
			if (involvedParty == PartyBase.MainParty)
			{
				involvedParty.MobileParty.Ai.ForceAiNoPathMode = false;
			}
			this.RecalculateRenownAndInfluenceValues(involvedParty);
			if (this.IsFieldBattle && involvedParty.IsMobile && involvedParty.MobileParty.BesiegedSettlement == null)
			{
				Vec2 vec = this.GetMapEventSide(side).LeaderParty.Position2D - this.Position;
				float num3 = vec.Normalize();
				if (involvedParty != this.GetMapEventSide(side).LeaderParty)
				{
					int num4 = this.GetMapEventSide(side).Parties.Count((MapEventParty p) => p.Party.IsMobile) - 1;
					involvedParty.MobileParty.EventPositionAdder = this.Position + vec * MathF.Max(num3, 0.4f) + (float)((num4 + 1) / 2 * ((num4 % 2 == 0) ? 1 : (-1))) * vec.RightVec() * 0.4f - (involvedParty.Position2D + involvedParty.MobileParty.ArmyPositionAdder);
				}
				else
				{
					involvedParty.MobileParty.EventPositionAdder = this.Position + vec * MathF.Max(num3, 0.4f) - (involvedParty.Position2D + involvedParty.MobileParty.ArmyPositionAdder);
				}
			}
			involvedParty.SetVisualAsDirty();
			if (involvedParty.IsMobile && involvedParty.MobileParty.Army != null && involvedParty.MobileParty.Army.LeaderParty == involvedParty.MobileParty)
			{
				foreach (MobileParty mobileParty in involvedParty.MobileParty.Army.LeaderParty.AttachedParties)
				{
					mobileParty.Party.SetVisualAsDirty();
				}
			}
			if (this.HasWinner && involvedParty.MapEventSide.MissionSide != this.WinningSide && involvedParty.NumberOfHealthyMembers > 0)
			{
				this.BattleState = BattleState.None;
			}
			if (involvedParty.IsVisible)
			{
				this.IsVisible = true;
			}
			this.ResetUnsuitablePartiesThatWereTargetingThisMapEvent();
		}

		public bool IsVisible
		{
			get
			{
				return this._isVisible;
			}
			private set
			{
				this._isVisible = value;
				IMapEventVisual mapEventVisual = this.MapEventVisual;
				if (mapEventVisual == null)
				{
					return;
				}
				mapEventVisual.SetVisibility(value);
			}
		}

		internal void PartyVisibilityChanged(PartyBase party, bool isPartyVisible)
		{
			if (isPartyVisible)
			{
				this.IsVisible = true;
				return;
			}
			bool flag = false;
			foreach (PartyBase partyBase in this.InvolvedParties)
			{
				if (partyBase != party && partyBase.IsVisible)
				{
					flag = true;
					break;
				}
			}
			this.IsVisible = flag;
		}

		internal void RemoveInvolvedPartyInternal(PartyBase party)
		{
			party.SetVisualAsDirty();
			if (party.IsMobile && party.MobileParty.Army != null && party.MobileParty.Army.LeaderParty == party.MobileParty)
			{
				foreach (MobileParty mobileParty in party.MobileParty.Army.LeaderParty.AttachedParties)
				{
					mobileParty.Party.SetVisualAsDirty();
				}
			}
			if (this.IsFieldBattle && party.IsMobile)
			{
				party.MobileParty.EventPositionAdder = Vec2.Zero;
				foreach (MapEventSide mapEventSide in this._sides)
				{
					MapEventParty[] array = mapEventSide.Parties.ToArray();
					Vec2 vec = mapEventSide.LeaderParty.Position2D - this.Position;
					float num = vec.Normalize();
					for (int j = 0; j < array.Length; j++)
					{
						PartyBase party2 = array[j].Party;
						if (party2.IsMobile && party2 != mapEventSide.LeaderParty)
						{
							party2.MobileParty.EventPositionAdder = this.Position + vec * MathF.Max(num, 0.4f) + (float)((j + 1) / 2 * ((j % 2 == 0) ? 1 : (-1))) * vec.RightVec() * 0.4f - (party2.Position2D + party2.MobileParty.ArmyPositionAdder);
						}
					}
				}
			}
			if (this.IsSiegeOutside)
			{
				MapEventSide mapEventSide2;
				if (this.MapEventSettlement == null)
				{
					mapEventSide2 = this.AttackerSide;
				}
				else
				{
					mapEventSide2 = this.DefenderSide;
				}
				if (mapEventSide2.Parties.All((MapEventParty x) => x.Party.MobileParty == null || (this.MapEventSettlement != null && x.Party.MobileParty.CurrentSettlement == this.MapEventSettlement)) && this.MapEventSettlement != null)
				{
					this._mapEventType = MapEvent.BattleTypes.Siege;
				}
			}
			if (party == PartyBase.MainParty && this.State == MapEventState.Wait)
			{
				this.AttackerSide.RemoveNearbyPartiesFromPlayerMapEvent();
				this.DefenderSide.RemoveNearbyPartiesFromPlayerMapEvent();
			}
			if (party.IsVisible)
			{
				this.PartyVisibilityChanged(party, false);
			}
			this.ResetUnsuitablePartiesThatWereTargetingThisMapEvent();
			if (party.IsMobile)
			{
				party.MobileParty.Ai.SetMoveModeHold();
			}
		}

		public int GetNumberOfInvolvedMen()
		{
			return this.DefenderSide.RecalculateMemberCountOfSide() + this.AttackerSide.RecalculateMemberCountOfSide();
		}

		public int GetNumberOfInvolvedMen(BattleSideEnum side)
		{
			return this.GetMapEventSide(side).RecalculateMemberCountOfSide();
		}

		private void LootDefeatedParties(out bool playerCaptured, LootCollector lootCollector)
		{
			this.GetMapEventSide(this.DefeatedSide).CollectAll(lootCollector, out playerCaptured);
		}

		internal void AddCasualtiesInBattle(TroopRoster troopRoster, LootCollector lootCollector)
		{
			lootCollector.CasualtiesInBattle.Add(troopRoster);
		}

		private int CalculatePlunderedGold()
		{
			float num = 0f;
			foreach (MapEventParty mapEventParty in this.GetMapEventSide(this.DefeatedSide).Parties)
			{
				PartyBase party = mapEventParty.Party;
				if (party.LeaderHero != null)
				{
					int num2 = Campaign.Current.Models.BattleRewardModel.CalculateGoldLossAfterDefeat(party.LeaderHero);
					num += (float)num2;
					mapEventParty.GoldLost = num2;
				}
				else if (party.IsMobile && party.MobileParty.IsPartyTradeActive)
				{
					int num3 = (int)(party.MobileParty.IsBandit ? ((float)party.MobileParty.PartyTradeGold * 0.5f) : ((float)party.MobileParty.PartyTradeGold * 0.1f));
					num += (float)num3;
					mapEventParty.GoldLost = num3;
				}
			}
			return (int)num;
		}

		private void CalculateRenownShares(MapEventResultExplainer resultExplainers = null, bool forScoreboard = false)
		{
			if (this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory)
			{
				((this.BattleState == BattleState.AttackerVictory) ? this.AttackerSide : this.DefenderSide).DistributeRenownAndInfluence(resultExplainers, forScoreboard);
			}
		}

		private void CalculateLootShares(LootCollector lootCollector)
		{
			if (this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory)
			{
				((this.BattleState == BattleState.AttackerVictory) ? this.AttackerSide : this.DefenderSide).DistributeLootAmongWinners(lootCollector);
			}
		}

		private int GetSimulatedDamage(CharacterObject strikerTroop, CharacterObject strikedTroop, PartyBase strikerParty, PartyBase strikedParty, float strikerAdvantage)
		{
			return Campaign.Current.Models.CombatSimulationModel.SimulateHit(strikerTroop, strikedTroop, strikerParty, strikedParty, strikerAdvantage, this);
		}

		private void SimulateBattleForRound(BattleSideEnum side, float advantage)
		{
			bool flag = this.AttackerSide.NumRemainingSimulationTroops == 0 || this.DefenderSide.NumRemainingSimulationTroops == 0 || this.SimulateSingleHit((int)side, (int)(BattleSideEnum.Attacker - side), advantage);
			if (flag)
			{
				bool flag2 = false;
				BattleState calculateWinner = this.GetCalculateWinner(ref flag2);
				if (calculateWinner != BattleState.None)
				{
					this.BattleState = calculateWinner;
					return;
				}
				if (flag2)
				{
					IBattleObserver battleObserver = this.BattleObserver;
					if (battleObserver == null)
					{
						return;
					}
					battleObserver.BattleResultsReady();
				}
			}
		}

		private bool SimulateSingleHit(int strikerSideIndex, int strikedSideIndex, float strikerAdvantage)
		{
			MapEventSide mapEventSide = this._sides[strikerSideIndex];
			MapEventSide mapEventSide2 = this._sides[strikedSideIndex];
			UniqueTroopDescriptor uniqueTroopDescriptor = mapEventSide.SelectRandomSimulationTroop();
			UniqueTroopDescriptor uniqueTroopDescriptor2 = mapEventSide2.SelectRandomSimulationTroop();
			CharacterObject allocatedTroop = mapEventSide.GetAllocatedTroop(uniqueTroopDescriptor);
			CharacterObject allocatedTroop2 = mapEventSide2.GetAllocatedTroop(uniqueTroopDescriptor2);
			PartyBase allocatedTroopParty = mapEventSide.GetAllocatedTroopParty(uniqueTroopDescriptor);
			PartyBase allocatedTroopParty2 = mapEventSide2.GetAllocatedTroopParty(uniqueTroopDescriptor2);
			int num = this.GetSimulatedDamage(allocatedTroop, allocatedTroop2, allocatedTroopParty, allocatedTroopParty2, strikerAdvantage);
			if (num > 0)
			{
				if (this.IsPlayerSimulation && allocatedTroopParty2 == PartyBase.MainParty)
				{
					float playerTroopsReceivedDamageMultiplier = Campaign.Current.Models.DifficultyModel.GetPlayerTroopsReceivedDamageMultiplier();
					num = MBRandom.RoundRandomized((float)num * playerTroopsReceivedDamageMultiplier);
				}
				DamageTypes damageTypes = ((MBRandom.RandomFloat < 0.3f) ? DamageTypes.Blunt : DamageTypes.Cut);
				bool flag = mapEventSide2.ApplySimulationDamageToSelectedTroop(num, damageTypes, allocatedTroopParty);
				mapEventSide.ApplySimulatedHitRewardToSelectedTroop(allocatedTroop, allocatedTroop2, num, flag);
				if (this.IsPlayerSimulation && allocatedTroopParty == PartyBase.MainParty && flag)
				{
					CampaignEventDispatcher.Instance.OnPlayerPartyKnockedOrKilledTroop(allocatedTroop2);
				}
				return flag;
			}
			return false;
		}

		private bool GetAttackersRunAwayChance()
		{
			if (this._mapEventUpdateCount <= 1)
			{
				return false;
			}
			if (this.AttackerSide.LeaderParty.LeaderHero == null)
			{
				return false;
			}
			if (this.IsSallyOut)
			{
				return false;
			}
			float num = 0f;
			foreach (MapEventParty mapEventParty in this.AttackerSide.Parties)
			{
				num += mapEventParty.Party.TotalStrength;
			}
			float num2 = 0f;
			foreach (MapEventParty mapEventParty2 in this.DefenderSide.Parties)
			{
				num2 += mapEventParty2.Party.TotalStrength;
			}
			if (this.IsSiegeAssault)
			{
				num *= 0.6666667f;
			}
			if (num2 > num * 1.1f)
			{
				float randomFloat = MBRandom.RandomFloat;
				float num3 = ((this._mapEventUpdateCount < 16) ? MathF.Sqrt((float)this._mapEventUpdateCount / 16f) : 1f);
				return randomFloat * num3 > num / (num2 * 1.1f);
			}
			return false;
		}

		internal void Update()
		{
			if (this._isFinishCalled)
			{
				return;
			}
			bool flag = false;
			if (this._sides[0].LeaderParty == null || this._sides[1].LeaderParty == null || !this._sides[0].LeaderParty.MapFaction.IsAtWarWith(this._sides[1].LeaderParty.MapFaction))
			{
				this.DiplomaticallyFinished = true;
			}
			if (!this.DiplomaticallyFinished)
			{
				MapEventComponent component = this.Component;
				if (component != null)
				{
					component.Update(ref flag);
				}
				if (((this.DefenderSide.TroopCount > 0 && this.AttackerSide.TroopCount > 0) || (!this.FirstUpdateIsDone && (this.DefenderSide.TroopCount > 0 || this._mapEventType != MapEvent.BattleTypes.Raid))) && this._nextSimulationTime.IsPast)
				{
					this.AttackersRanAway = this._mapEventType != MapEvent.BattleTypes.Siege && this._mapEventType != MapEvent.BattleTypes.SallyOut && this._mapEventType != MapEvent.BattleTypes.SiegeOutside && this._mapEventType != MapEvent.BattleTypes.Raid && this.GetAttackersRunAwayChance();
					this._mapEventUpdateCount++;
					if (!this.AttackersRanAway)
					{
						this.SimulateBattleSessionForMapEvent();
						this._nextSimulationTime = MapEvent.CalculateNextSimulationTime();
						this.FirstUpdateIsDone = true;
					}
					else
					{
						flag = true;
					}
				}
				if ((this._mapEventType != MapEvent.BattleTypes.Raid || this.DefenderSide.Parties.Count > 1) && this.BattleState != BattleState.None)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
				foreach (PartyBase partyBase in this.InvolvedParties)
				{
					if (partyBase.IsMobile && partyBase.MobileParty != MobileParty.MainParty && (partyBase.MobileParty.Army == null || partyBase.MobileParty.Army.LeaderParty == partyBase.MobileParty))
					{
						partyBase.MobileParty.Ai.RecalculateShortTermAi();
					}
				}
			}
			if (flag)
			{
				MapEventComponent component2 = this.Component;
				if (component2 != null)
				{
					component2.Finish();
				}
				if (!this.IsPlayerMapEvent || PlayerEncounter.Current == null)
				{
					this.FinishBattle();
				}
			}
		}

		public void FinishBattleAndKeepSiegeEvent()
		{
			this._keepSiegeEvent = true;
			this.FinishBattle();
		}

		private void CheckSiegeStageChange()
		{
			if (this.MapEventSettlement != null && this.IsSiegeAssault)
			{
				bool flag = this.AttackerSide.Parties.Sum((MapEventParty party) => party.Party.NumberOfHealthyMembers) != 0;
				int num = this.DefenderSide.Parties.Sum((MapEventParty party) => party.Party.NumberOfHealthyMembers);
				if (flag)
				{
				}
				return;
			}
		}

		public void SimulateBattleSetup(FlattenedTroopRoster[] priorTroops)
		{
			if (this.IsSiegeAssault)
			{
				this.CheckSiegeStageChange();
			}
			foreach (MapEventSide mapEventSide in this._sides)
			{
				FlattenedTroopRoster flattenedTroopRoster = ((priorTroops != null) ? priorTroops[(int)mapEventSide.MissionSide] : null);
				mapEventSide.MakeReadyForSimulation(flattenedTroopRoster, (flattenedTroopRoster != null) ? flattenedTroopRoster.Count<FlattenedTroopRosterElement>() : (-1));
			}
			this._battleState = BattleState.None;
		}

		public void SimulateBattleForRounds(int simulationRoundsDefender, int simulationRoundsAttacker)
		{
			bool flag = false;
			this.BattleState = this.GetCalculateWinner(ref flag);
			ValueTuple<float, float> battleAdvantage = Campaign.Current.Models.CombatSimulationModel.GetBattleAdvantage(this.DefenderSide.LeaderParty, this.AttackerSide.LeaderParty, this._mapEventType, this.MapEventSettlement);
			float item = battleAdvantage.Item1;
			float item2 = battleAdvantage.Item2;
			int num = 0;
			while (0 < simulationRoundsAttacker + simulationRoundsDefender && this.BattleState == BattleState.None)
			{
				float num2 = (float)simulationRoundsAttacker / (float)(simulationRoundsAttacker + simulationRoundsDefender);
				if (MBRandom.RandomFloat < num2)
				{
					simulationRoundsAttacker--;
					this.SimulateBattleForRound(BattleSideEnum.Attacker, item2);
				}
				else
				{
					simulationRoundsDefender--;
					this.SimulateBattleForRound(BattleSideEnum.Defender, item);
				}
				num++;
			}
		}

		private void SimulateBattleSessionForMapEvent()
		{
			this.SimulateBattleSetup(null);
			ValueTuple<int, int> simulationRoundsForBattle = Campaign.Current.Models.CombatSimulationModel.GetSimulationRoundsForBattle(this, this.DefenderSide.NumRemainingSimulationTroops, this.AttackerSide.NumRemainingSimulationTroops);
			int item = simulationRoundsForBattle.Item1;
			int item2 = simulationRoundsForBattle.Item2;
			this.SimulateBattleForRounds(item, item2);
			this.SimulateBattleEndSession();
		}

		internal void SimulatePlayerEncounterBattle()
		{
			ValueTuple<int, int> simulationRoundsForBattle = Campaign.Current.Models.CombatSimulationModel.GetSimulationRoundsForBattle(this, this.DefenderSide.NumRemainingSimulationTroops, this.AttackerSide.NumRemainingSimulationTroops);
			int item = simulationRoundsForBattle.Item1;
			int item2 = simulationRoundsForBattle.Item2;
			this.SimulateBattleForRounds(item, item2);
		}

		private void SimulateBattleEndSession()
		{
			this.CommitXpGains();
			this.ApplyRenownAndInfluenceChanges();
			this.ApplyRewardsAndChanges();
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				sides[i].EndSimulation();
			}
		}

		public bool IsPlayerMapEvent
		{
			get
			{
				return this == MapEvent.PlayerMapEvent;
			}
		}

		public bool IsFinished
		{
			get
			{
				return this._state == MapEventState.WaitingRemoval;
			}
		}

		public BattleState BattleState
		{
			get
			{
				return this._battleState;
			}
			internal set
			{
				if (value != this._battleState)
				{
					if (this.IsPlayerMapEvent)
					{
						Debug.Print("Player MapEvent BattleState: " + value.ToString(), 0, Debug.DebugColor.White, 17592186044416UL);
					}
					this._battleState = value;
					if (this._battleState == BattleState.AttackerVictory || this._battleState == BattleState.DefenderVictory)
					{
						this.OnBattleWon(this._battleState);
					}
				}
			}
		}

		public MapEventSide Winner
		{
			get
			{
				if (this.BattleState == BattleState.AttackerVictory)
				{
					return this.AttackerSide;
				}
				if (this.BattleState != BattleState.DefenderVictory)
				{
					return null;
				}
				return this.DefenderSide;
			}
		}

		private void OnBattleWon(BattleState winnerSide)
		{
			this.CalculateBattleResults(true);
			IBattleObserver battleObserver = this.BattleObserver;
			if (battleObserver == null)
			{
				return;
			}
			battleObserver.BattleResultsReady();
		}

		public BattleSideEnum WinningSide
		{
			get
			{
				if (this.BattleState == BattleState.AttackerVictory)
				{
					return BattleSideEnum.Attacker;
				}
				if (this.BattleState != BattleState.DefenderVictory)
				{
					return BattleSideEnum.None;
				}
				return BattleSideEnum.Defender;
			}
		}

		public BattleSideEnum DefeatedSide
		{
			get
			{
				if (this.BattleState == BattleState.AttackerVictory)
				{
					return BattleSideEnum.Defender;
				}
				if (this.BattleState != BattleState.DefenderVictory)
				{
					return BattleSideEnum.None;
				}
				return BattleSideEnum.Attacker;
			}
		}

		private BattleState GetCalculateWinner(ref bool isRoundWinnerDetermined)
		{
			BattleState battleState = BattleState.None;
			int num = this.AttackerSide.NumRemainingSimulationTroops;
			int num2 = this.DefenderSide.NumRemainingSimulationTroops;
			if (this.IsPlayerSimulation && !Hero.MainHero.IsWounded && this.InvolvedParties.Contains(PartyBase.MainParty))
			{
				if (PartyBase.MainParty.Side == BattleSideEnum.Attacker)
				{
					if (num == 0)
					{
						isRoundWinnerDetermined = true;
					}
					num++;
				}
				else if (PartyBase.MainParty.Side == BattleSideEnum.Defender)
				{
					if (num2 == 0)
					{
						isRoundWinnerDetermined = true;
					}
					num2++;
				}
			}
			if (num == 0)
			{
				battleState = BattleState.DefenderVictory;
			}
			else if (num2 == 0)
			{
				battleState = BattleState.AttackerVictory;
			}
			return battleState;
		}

		public void SetOverrideWinner(BattleSideEnum winner)
		{
			this.BattleState = ((winner == BattleSideEnum.Attacker) ? BattleState.AttackerVictory : ((winner == BattleSideEnum.Defender) ? BattleState.DefenderVictory : BattleState.None));
		}

		public void SetDefenderPulledBack()
		{
			this.BattleState = BattleState.DefenderPullBack;
		}

		public void ResetBattleState()
		{
			this.BattleState = BattleState.None;
		}

		internal bool CheckIfOneSideHasLost()
		{
			int num = this.DefenderSide.RecalculateMemberCountOfSide();
			int num2 = this.AttackerSide.RecalculateMemberCountOfSide();
			if (this.BattleState == BattleState.None && (num == 0 || num2 == 0))
			{
				this.BattleState = ((num2 > 0) ? BattleState.AttackerVictory : BattleState.DefenderVictory);
			}
			return this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory;
		}

		internal ItemRoster ItemRosterForPlayerLootShare(PartyBase party)
		{
			return this.GetMapEventSide(party.Side).ItemRosterForPlayerLootShare(party);
		}

		public bool IsPlayerSergeant()
		{
			return this.IsPlayerMapEvent && this.GetLeaderParty(this.PlayerSide) != PartyBase.MainParty && MobileParty.MainParty.Army != null && MobileParty.MainParty.Army.LeaderParty != MobileParty.MainParty;
		}

		private void FinishBattle()
		{
			List<MobileParty> list = new List<MobileParty>();
			if (this.AttackersRanAway)
			{
				foreach (MapEventParty mapEventParty in this.AttackerSide.Parties)
				{
					if (mapEventParty.Party.IsMobile)
					{
						list.Add(mapEventParty.Party.MobileParty);
					}
				}
			}
			this._isFinishCalled = true;
			if (!this._battleResultsCalculated)
			{
				this.CalculateBattleResults(false);
			}
			this.ApplyBattleResults();
			this.FinalizeEventAux();
			if (this.AttackersRanAway)
			{
				foreach (MobileParty mobileParty in list)
				{
					if (mobileParty.IsActive && mobileParty.AttachedTo == null)
					{
						if (mobileParty.BesiegerCamp != null)
						{
							mobileParty.BesiegerCamp = null;
						}
						mobileParty.TeleportPartyToSafePosition(3.3f, 3f);
						mobileParty.Ai.SetMoveModeHold();
					}
				}
			}
		}

		public MapEventResultExplainer BattleResultExplainers
		{
			get
			{
				return this._battleResultExplainers;
			}
		}

		public override string ToString()
		{
			object[] array = new object[4];
			array[0] = "Battle: ";
			int num = 1;
			PartyBase leaderParty = this.AttackerSide.LeaderParty;
			array[num] = ((leaderParty != null) ? leaderParty.Name : null);
			array[2] = " x ";
			array[3] = this.DefenderSide.LeaderParty.Name;
			return string.Concat(array);
		}

		internal void CalculateBattleResults(bool forScoreBoard = false)
		{
			if (this._battleResultsCalculated)
			{
				return;
			}
			this._battleResultsCalculated = !forScoreBoard;
			LootCollector lootCollector = new LootCollector();
			if (this.IsPlayerMapEvent)
			{
				this._battleResultExplainers = new MapEventResultExplainer();
				if (PlayerEncounter.EncounteredPartySurrendered)
				{
					this._sides[(int)this.DefeatedSide.GetOppositeSide()].ResetContributionToBattleToStrength();
				}
			}
			if (this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory)
			{
				int num = this.CalculatePlunderedGold();
				if (!forScoreBoard)
				{
					this.LootDefeatedParties(out this.PlayerCaptured, lootCollector);
					this.CalculatePlunderedGoldShares((float)num, this._battleResultExplainers);
				}
				if (!forScoreBoard)
				{
					this.CalculateLootShares(lootCollector);
				}
				this.CalculateRenownShares(this._battleResultExplainers, forScoreBoard);
			}
		}

		private void CalculatePlunderedGoldShares(float totalPlunderedGold, MapEventResultExplainer resultExplainers = null)
		{
			if (this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory)
			{
				((this.BattleState == BattleState.AttackerVictory) ? this.AttackerSide : this.DefenderSide).CalculatePlunderedGoldShare(totalPlunderedGold, resultExplainers);
			}
		}

		internal void ApplyBattleResults()
		{
			if (this._battleResultsCommitted)
			{
				return;
			}
			this.CommitXpGains();
			this.ApplyRenownAndInfluenceChanges();
			this.ApplyRewardsAndChanges();
			this._battleResultsCommitted = true;
		}

		private void ApplyRewardsAndChanges()
		{
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				sides[i].ApplyFinalRewardsAndChanges();
			}
		}

		internal void ApplyRenownAndInfluenceChanges()
		{
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				sides[i].ApplyRenownAndInfluenceChanges();
			}
		}

		private void CommitXpGains()
		{
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				sides[i].CommitXpGains();
			}
		}

		internal void ResetBattleResults()
		{
			this._battleResultsCommitted = false;
		}

		public bool IsFinalized
		{
			get
			{
				return this._state == MapEventState.WaitingRemoval;
			}
		}

		public void FinalizeEvent()
		{
			this.FinalizeEventAux();
		}

		private void FinalizeEventAux()
		{
			if (this.IsFinalized)
			{
				return;
			}
			this.State = MapEventState.WaitingRemoval;
			CampaignEventDispatcher.Instance.OnMapEventEnded(this);
			if (this.MapEventSettlement != null)
			{
				if ((this.IsSiegeAssault || this.IsSiegeOutside || this.IsSallyOut) && this.MapEventSettlement.SiegeEvent != null)
				{
					this.MapEventSettlement.SiegeEvent.OnBeforeSiegeEventEnd(this.BattleState, this._mapEventType);
				}
				if (!this._keepSiegeEvent && (this.IsSiegeAssault || this.IsSiegeOutside))
				{
					BattleState battleState = this.BattleState;
					if (battleState != BattleState.DefenderVictory)
					{
						if (battleState == BattleState.AttackerVictory)
						{
							CampaignEventDispatcher.Instance.SiegeCompleted(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty, true, this._mapEventType);
						}
					}
					else
					{
						SiegeEvent siegeEvent = this.MapEventSettlement.SiegeEvent;
						if (siegeEvent != null)
						{
							siegeEvent.BesiegerCamp.RemoveAllSiegeParties();
						}
						CampaignEventDispatcher.Instance.SiegeCompleted(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty, false, this._mapEventType);
					}
				}
				else if (this.IsSallyOut && this.MapEventSettlement.Town != null && this.MapEventSettlement.Town.GarrisonParty != null && this.MapEventSettlement.Town.GarrisonParty.IsActive)
				{
					this.MapEventSettlement.Town.GarrisonParty.Ai.SetMoveModeHold();
				}
				MapEventComponent component = this.Component;
				if (component != null)
				{
					component.FinalizeComponent();
				}
			}
			foreach (MapEventSide mapEventSide in this._sides)
			{
				mapEventSide.UpdatePartiesMoveState();
				mapEventSide.HandleMapEventEnd();
			}
			IMapEventVisual mapEventVisual = this.MapEventVisual;
			if (mapEventVisual != null)
			{
				mapEventVisual.OnMapEventEnd();
			}
			foreach (PartyBase partyBase in this.InvolvedParties)
			{
				if (partyBase.IsMobile)
				{
					partyBase.MobileParty.EventPositionAdder = Vec2.Zero;
				}
				partyBase.SetVisualAsDirty();
				if (partyBase.IsMobile && partyBase.MobileParty.Army != null && partyBase.MobileParty.Army.LeaderParty == partyBase.MobileParty)
				{
					foreach (MobileParty mobileParty in partyBase.MobileParty.Army.LeaderParty.AttachedParties)
					{
						mobileParty.Party.SetVisualAsDirty();
					}
				}
			}
			if (this._mapEventType != MapEvent.BattleTypes.Siege && this._mapEventType != MapEvent.BattleTypes.SiegeOutside && this._mapEventType != MapEvent.BattleTypes.SallyOut)
			{
				foreach (PartyBase partyBase2 in this.InvolvedParties)
				{
					if (partyBase2.IsMobile && partyBase2 != PartyBase.MainParty && partyBase2.MobileParty.BesiegedSettlement != null && (partyBase2.MobileParty.Army == null || partyBase2.MobileParty.Army.LeaderParty == partyBase2.MobileParty))
					{
						if (partyBase2.IsActive)
						{
							EncounterManager.StartSettlementEncounter(partyBase2.MobileParty, partyBase2.MobileParty.BesiegedSettlement);
						}
						else
						{
							partyBase2.MobileParty.BesiegerCamp = null;
						}
					}
				}
			}
			MapEventSide[] array = this._sides;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
		}

		public CampaignTime BattleStartTime
		{
			get
			{
				return this._mapEventStartTime;
			}
		}

		public bool HasWinner
		{
			get
			{
				return this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory;
			}
		}

		[SaveableProperty(123)]
		public bool IsPlayerSimulation { get; set; }

		public bool HasTroopsOnBothSides()
		{
			bool flag = this.PartiesOnSide(BattleSideEnum.Attacker).Any((MapEventParty party) => party.Party.NumberOfHealthyMembers > 0);
			bool flag2 = this.PartiesOnSide(BattleSideEnum.Defender).Any((MapEventParty party) => party.Party.NumberOfHealthyMembers > 0);
			return flag && flag2;
		}

		public PartyBase GetLeaderParty(BattleSideEnum side)
		{
			return this._sides[(int)side].LeaderParty;
		}

		public float GetRenownValue(BattleSideEnum side)
		{
			return this._sides[(int)side].RenownValue;
		}

		public float GetRenownValueAtMapEventEnd(BattleSideEnum side)
		{
			return this._sides[(int)side].RenownAtMapEventEnd;
		}

		public void RecalculateRenownAndInfluenceValues(PartyBase party)
		{
			this.StrengthOfSide[(int)party.Side] += party.TotalStrength;
			MapEventSide[] sides = this._sides;
			for (int i = 0; i < sides.Length; i++)
			{
				sides[i].CalculateRenownAndInfluenceValues(this.StrengthOfSide);
			}
		}

		public void RecalculateStrengthOfSides()
		{
			foreach (MapEventSide mapEventSide in this._sides)
			{
				this.StrengthOfSide[(int)mapEventSide.MissionSide] = mapEventSide.RecalculateStrengthOfSide();
			}
		}

		public void DoSurrender(BattleSideEnum side)
		{
			this.GetMapEventSide(side).Surrender();
			this.BattleState = ((side == BattleSideEnum.Defender) ? BattleState.AttackerVictory : BattleState.DefenderVictory);
		}

		internal BattleSideEnum GetOtherSide(BattleSideEnum side)
		{
			if (side != BattleSideEnum.Attacker)
			{
				return BattleSideEnum.Attacker;
			}
			return BattleSideEnum.Defender;
		}

		private void ResetUnsuitablePartiesThatWereTargetingThisMapEvent()
		{
			LocatableSearchData<MobileParty> locatableSearchData = MobileParty.StartFindingLocatablesAroundPosition(this.Position, 15f);
			for (MobileParty mobileParty = MobileParty.FindNextLocatable(ref locatableSearchData); mobileParty != null; mobileParty = MobileParty.FindNextLocatable(ref locatableSearchData))
			{
				if (!mobileParty.IsMainParty && mobileParty.ShortTermBehavior == AiBehavior.EngageParty && (mobileParty.ShortTermTargetParty == this.GetLeaderParty(BattleSideEnum.Attacker).MobileParty || mobileParty.ShortTermTargetParty == this.GetLeaderParty(BattleSideEnum.Defender).MobileParty) && !this.CanPartyJoinBattle(mobileParty.Party, BattleSideEnum.Attacker) && !this.CanPartyJoinBattle(mobileParty.Party, BattleSideEnum.Defender))
				{
					mobileParty.Ai.SetMoveModeHold();
				}
			}
		}

		private void CacheSimulationData()
		{
			this._sides[0].CacheLeaderSimulationModifier();
			this._sides[1].CacheLeaderSimulationModifier();
			this.SimulationContext = this.DetermineContext();
		}

		private MapEvent.PowerCalculationContext DetermineContext()
		{
			MapEvent.PowerCalculationContext powerCalculationContext = MapEvent.PowerCalculationContext.Default;
			MapWeatherModel.WeatherEvent weatherEventInPosition = Campaign.Current.Models.MapWeatherModel.GetWeatherEventInPosition(this.Position);
			if (weatherEventInPosition == MapWeatherModel.WeatherEvent.Snowy || weatherEventInPosition == MapWeatherModel.WeatherEvent.Blizzard)
			{
				powerCalculationContext = MapEvent.PowerCalculationContext.SnowBattle;
			}
			switch (this.EventType)
			{
			case MapEvent.BattleTypes.FieldBattle:
			case MapEvent.BattleTypes.SallyOut:
			case MapEvent.BattleTypes.SiegeOutside:
				switch (this.EventTerrainType)
				{
				case TerrainType.Water:
				case TerrainType.Swamp:
				case TerrainType.Bridge:
				case TerrainType.River:
				case TerrainType.Fording:
				case TerrainType.Lake:
					powerCalculationContext = MapEvent.PowerCalculationContext.RiverCrossingBattle;
					break;
				case TerrainType.Steppe:
					powerCalculationContext = MapEvent.PowerCalculationContext.SteppeBattle;
					break;
				case TerrainType.Plain:
					powerCalculationContext = MapEvent.PowerCalculationContext.PlainBattle;
					break;
				case TerrainType.Desert:
					powerCalculationContext = MapEvent.PowerCalculationContext.DesertBattle;
					break;
				case TerrainType.Dune:
					powerCalculationContext = MapEvent.PowerCalculationContext.DuneBattle;
					break;
				case TerrainType.Forest:
					powerCalculationContext = MapEvent.PowerCalculationContext.ForestBattle;
					break;
				}
				break;
			case MapEvent.BattleTypes.Raid:
			case MapEvent.BattleTypes.IsForcingVolunteers:
			case MapEvent.BattleTypes.IsForcingSupplies:
				powerCalculationContext = MapEvent.PowerCalculationContext.Village;
				break;
			case MapEvent.BattleTypes.Siege:
				powerCalculationContext = MapEvent.PowerCalculationContext.Siege;
				break;
			}
			return powerCalculationContext;
		}

		Vec2 IMapEntity.InteractionPosition
		{
			get
			{
				return this.Position;
			}
		}

		TextObject IMapEntity.Name
		{
			get
			{
				return this.GetName();
			}
		}

		bool IMapEntity.IsMobileEntity
		{
			get
			{
				return false;
			}
		}

		bool IMapEntity.ShowCircleAroundEntity
		{
			get
			{
				return false;
			}
		}

		bool IMapEntity.OnMapClick(bool followModifierUsed)
		{
			return false;
		}

		void IMapEntity.OnOpenEncyclopedia()
		{
		}

		void IMapEntity.OnHover()
		{
			InformationManager.ShowTooltip(typeof(MapEvent), new object[] { this });
		}

		bool IMapEntity.IsEnemyOf(IFaction faction)
		{
			return false;
		}

		bool IMapEntity.IsAllyOf(IFaction faction)
		{
			return false;
		}

		public void GetMountAndHarnessVisualIdsForPartyIcon(out string mountStringId, out string harnessStringId)
		{
			mountStringId = "";
			harnessStringId = "";
		}

		void IMapEntity.OnPartyInteraction(MobileParty mobileParty)
		{
		}

		public bool CanPartyJoinBattle(PartyBase party, BattleSideEnum side)
		{
			return this.GetMapEventSide(side).Parties.All((MapEventParty x) => !x.Party.MapFaction.IsAtWarWith(party.MapFaction)) && this.GetMapEventSide(this.GetOtherSide(side)).Parties.All((MapEventParty x) => x.Party.MapFaction.IsAtWarWith(party.MapFaction));
		}

		public void GetStrengthsRelativeToParty(BattleSideEnum partySide, out float partySideStrength, out float opposingSideStrength)
		{
			partySideStrength = 0.1f;
			opposingSideStrength = 0.1f;
			if (this != null)
			{
				using (IEnumerator<PartyBase> enumerator = this.InvolvedParties.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						PartyBase partyBase = enumerator.Current;
						if (partyBase.Side == partySide)
						{
							partySideStrength += partyBase.TotalStrength;
						}
						else
						{
							opposingSideStrength += partyBase.TotalStrength;
						}
					}
					return;
				}
			}
			Debug.FailedAssert("Cannot retrieve party strengths. MapEvent parameter is null.", "C:\\Develop\\MB3\\Source\\Bannerlord\\TaleWorlds.CampaignSystem\\MapEvents\\MapEvent.cs", "GetStrengthsRelativeToParty", 1929);
		}

		public bool CheckIfBattleShouldContinueAfterBattleMission(CampaignBattleResult campaignBattleResult)
		{
			if (PlayerEncounter.PlayerSurrender || campaignBattleResult == null || campaignBattleResult.EnemyRetreated)
			{
				return false;
			}
			bool flag = this.IsSiegeAssault && this.BattleState == BattleState.AttackerVictory;
			MapEventSide mapEventSide = this.GetMapEventSide(this.PlayerSide);
			bool flag2 = (campaignBattleResult.PlayerDefeat && mapEventSide.GetTotalHealthyTroopCountOfSide() >= 1) || ((campaignBattleResult.PlayerVictory || campaignBattleResult.EnemyPulledBack) && this.DefeatedSide != BattleSideEnum.None && this.GetMapEventSide(this.DefeatedSide).GetTotalHealthyTroopCountOfSide() >= 1);
			return !this.IsHideoutBattle && !flag && flag2 && !mapEventSide.IsSurrendered;
		}

		private const float BattleRetreatMinimumTime = 1f;

		private const float SiegeDefenderAdvantage = 2f;

		private const int MapEventSettlementSettingDistance = 3;

		[SaveableField(101)]
		private MapEventState _state;

		[SaveableField(102)]
		private MapEventSide[] _sides = new MapEventSide[2];

		public const float SiegeAdvantage = 1.5f;

		public bool DiplomaticallyFinished;

		[SaveableField(106)]
		private int _mapEventUpdateCount;

		[CachedData]
		internal MapEvent.PowerCalculationContext SimulationContext;

		[SaveableField(107)]
		private CampaignTime _nextSimulationTime;

		[SaveableField(108)]
		private CampaignTime _mapEventStartTime;

		[SaveableField(110)]
		private MapEvent.BattleTypes _mapEventType;

		[CachedData]
		private TerrainType _eventTerrainType;

		[CachedData]
		public IMapEventVisual MapEventVisual;

		[SaveableField(114)]
		private bool _isVisible;

		private bool _keepSiegeEvent;

		[SaveableField(116)]
		private bool FirstUpdateIsDone;

		[SaveableField(117)]
		private BattleState _battleState;

		private bool _isFinishCalled;

		private bool _battleResultsCalculated;

		private bool _battleResultsCommitted;

		private bool PlayerCaptured;

		private MapEventResultExplainer _battleResultExplainers;

		[SaveableField(125)]
		public float[] StrengthOfSide = new float[2];

		public enum BattleTypes
		{
			None,
			FieldBattle,
			Raid,
			IsForcingVolunteers,
			IsForcingSupplies,
			Siege,
			Hideout,
			SallyOut,
			SiegeOutside
		}

		public enum PowerCalculationContext
		{
			Default,
			PlainBattle,
			SteppeBattle,
			DesertBattle,
			DuneBattle,
			SnowBattle,
			ForestBattle,
			RiverCrossingBattle,
			Village,
			Siege
		}
	}
}
